<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>重构以提高模块性和错误处理 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch12-03-improving-error-handling-and-modularity.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refactoring-to-improve-modularity-and-error-handling"><a class="header" href="#refactoring-to-improve-modularity-and-error-handling">重构以提高模块性和错误处理</a></h2>
<p data-x-en="To improve our program, we’ll fix four problems that have to do with the program’s structure and how it’s handling potential errors. First, our main function now performs two tasks: it parses arguments and reads files. As our program grows, the number of separate tasks the main function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It’s best to separate functionality so each function is responsible for one task.">为了改进我们的程序，我们将解决四个与程序结构和处理潜在错误相关的问题。首先，我们的<code>main</code>函数现在执行两个任务：解析参数和读取文件。随着程序的增长，<code>main</code>函数处理的独立任务数量将会增加。随着函数职责的增加，理解和测试函数变得越来越困难，修改函数而不破坏其部分功能也变得更加困难。最好将功能分离，使每个函数只负责一个任务。</p>
<p data-x-en="This issue also ties into the second problem: although query and file_path are configuration variables to our program, variables like contents are used to perform the program’s logic. The longer main becomes, the more variables we’ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It’s best to group the configuration variables into one structure to make their purpose clear.">这个问题也与第二个问题相关：虽然 <code>query</code> 和 <code>file_path</code> 是我们程序的配置变量，但像 <code>contents</code> 这样的变量用于执行程序的逻辑。随着 <code>main</code> 变得越来越长，我们需要引入的变量也会越来越多；我们拥有的变量越多，就越难跟踪每个变量的用途。最好将配置变量组合到一个结构中，以明确它们的用途。</p>
<p data-x-en="The third problem is that we’ve used expect to print an error message when reading the file fails, but the error message just prints Should have been able to read the file. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we’d print the same error message for everything, which wouldn’t give the user any information!">第三个问题是，我们使用了<code>expect</code>在读取文件失败时打印错误消息，但错误消息只是打印<code>Should have been able to read the file</code>。读取文件可能会以多种方式失败：例如，文件可能不存在，或者我们可能没有权限打开它。现在，无论情况如何，我们都会为所有情况打印相同的错误消息，这不会给用户提供任何信息！</p>
<p data-x-en="Fourth, we use expect to handle an error, and if the user runs our program without specifying enough arguments, they’ll get an index out of bounds error from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we’re printing messages that will be meaningful to our end users.">第四，我们使用<code>expect</code>来处理错误，如果用户在运行我们的程序时没有指定足够的参数，他们将收到一个来自Rust的<code>index out of bounds</code>错误，这个错误没有清楚地解释问题。如果所有的错误处理代码都在一个地方，那么将来维护者只需要在一个地方查看代码，如果需要更改错误处理逻辑，这样会更好。将所有的错误处理代码放在一个地方，还可以确保我们打印的消息对最终用户来说是有意义的。</p>
<p data-x-en="Let’s address these four problems by refactoring our project.">让我们通过重构项目来解决这四个问题。</p>
<h3 id="separation-of-concerns-for-binary-projects"><a class="header" href="#separation-of-concerns-for-binary-projects">二进制项目中的关注点分离</a></h3>
<p data-x-en="The organizational problem of allocating responsibility for multiple tasks to the main function is common to many binary projects. As a result, the Rust community has developed guidelines for splitting the separate concerns of a binary program when main starts getting large. This process has the following steps:">将多个任务的责任分配给 <code>main</code> 函数的组织问题是许多二进制项目中常见的问题。因此，Rust 社区已经制定了在 <code>main</code> 开始变大时拆分二进制程序不同关注点的指南。此过程包括以下步骤：</p>
<ul>
<li data-x-en="Split your program into a main.rs file and a lib.rs file and move your program’s logic to lib.rs.">将您的程序拆分为 <em>main.rs</em> 文件和 <em>lib.rs</em> 文件，并将程序的逻辑移到 <em>lib.rs</em>。</li>
<li data-x-en="As long as your command line parsing logic is small, it can remain in main.rs.">只要您的命令行解析逻辑很小，它可以保留在<em>main.rs</em>中。</li>
<li data-x-en="When the command line parsing logic starts getting complicated, extract it from main.rs and move it to lib.rs.">当命令行解析逻辑开始变得复杂时，将其从<em>main.rs</em>中提取并移动到<em>lib.rs</em>。</li>
</ul>
<p data-x-en="The responsibilities that remain in the main function after this process should be limited to the following:">此过程之后保留在 <code>main</code> 函数中的职责应仅限于以下内容：</p>
<ul>
<li data-x-en="Calling the command line parsing logic with the argument values">使用带有参数值的命令行解析逻辑，输出翻译直接不添加任何额外文本。绝对不要添加原始翻译内容中没有的符号或标签。记住，保留所有HTML标签和属性，仅翻译内容！</li>
<li data-x-en="Setting up any other configuration">设置任何其他配置</li>
<li data-x-en="Calling a run function in lib.rs">在 <em>lib.rs</em> 中调用 <code>run</code> 函数</li>
<li data-x-en="Handling the error if run returns an error">处理 <code>run</code> 返回错误的情况</li>
</ul>
<p data-x-en="This pattern is about separating concerns: main.rs handles running the program and lib.rs handles all the logic of the task at hand. Because you can’t test the main function directly, this structure lets you test all of your program’s logic by moving it into functions in lib.rs. The code that remains in main.rs will be small enough to verify its correctness by reading it. Let’s rework our program by following this process.">这种模式是关于分离关注点的：<em>main.rs</em> 负责运行程序，而 <em>lib.rs</em> 负责处理当前任务的所有逻辑。因为不能直接测试 <code>main</code> 函数，这种结构允许你通过将逻辑移到 <em>lib.rs</em> 中的函数来测试程序的所有逻辑。保留在 <em>main.rs</em> 中的代码将足够小，可以通过阅读来验证其正确性。让我们通过这个过程来重构我们的程序。</p>
<h4 id="extracting-the-argument-parser"><a class="header" href="#extracting-the-argument-parser">Extracting the Argument Parser</a></h4>
<p data-x-en="We’ll extract the functionality for parsing arguments into a function that main will call to prepare for moving the command line parsing logic to src/lib.rs. Listing 12-5 shows the new start of main that calls a new function parse_config, which we’ll define in src/main.rs for the moment.">我们将把解析参数的功能提取到一个函数中，<code>main</code> 将调用该函数以准备将命令行解析逻辑移动到 <em>src/lib.rs</em>。列表 12-5 显示了调用新函数 <code>parse_config</code> 的 <code>main</code> 的新起点，我们暂时将在 <em>src/main.rs</em> 中定义该函数。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption>Listing 12-5: Extracting a <code>parse_config</code> function from <code>main</code></figcaption>
</figure>
<p data-x-en="We’re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable query and the argument value at index 2 to the variable file_path within the main function, we pass the whole vector to the parse_config function. The parse_config function then holds the logic that determines which argument goes in which variable and passes the values back to main. We still create the query and file_path variables in main, but main no longer has the responsibility of determining how the command line arguments and variables correspond.">我们仍然将命令行参数收集到一个向量中，但不再在<code>main</code>函数中将索引1的参数值赋给变量<code>query</code>，将索引2的参数值赋给变量<code>file_path</code>，而是将整个向量传递给<code>parse_config</code>函数。<code>parse_config</code>函数然后包含确定哪个参数进入哪个变量的逻辑，并将值传递回<code>main</code>。我们仍然在<code>main</code>中创建<code>query</code>和<code>file_path</code>变量，但<code>main</code>不再负责确定命令行参数和变量如何对应。</p>
<p data-x-en="This rework may seem like overkill for our small program, but we’re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It’s good to check your progress often, to help identify the cause of problems when they occur.">这个重构对于我们的小程序来说可能看起来有些过度，但我们正在以小的、增量的步骤进行重构。在进行此更改后，再次运行程序以验证参数解析是否仍然有效。经常检查你的进度是很好的，这有助于在问题发生时确定问题的原因。</p>
<h4 id="grouping-configuration-values"><a class="header" href="#grouping-configuration-values">Grouping Configuration Values</a></h4>
<p data-x-en="We can take another small step to improve the parse_config function further. At the moment, we’re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don’t have the right abstraction yet.">我们可以再迈出一小步来进一步改进 <code>parse_config</code> 函数。
目前，我们返回的是一个元组，但紧接着我们又立即将这个元组拆分成单独的部分。这表明我们可能还没有找到正确的抽象。</p>
<p data-x-en="Another indicator that shows there’s room for improvement is the config part of parse_config, which implies that the two values we return are related and are both part of one configuration value. We’re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we’ll instead put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.">另一个表明有改进空间的指标是 <code>parse_config</code> 中的 <code>config</code> 部分，这表明我们返回的两个值是相关的，并且都是一个配置值的一部分。我们目前除了将这两个值组合成一个元组外，并没有在数据结构中传达这种含义；我们将把这两个值放入一个结构体中，并为每个结构体字段赋予一个有意义的名称。这样做将使未来的代码维护者更容易理解不同值之间的关系及其目的。</p>
<p data-x-en="Listing 12-6 shows the improvements to the parse_config function.">列表 12-6 显示了对 <code>parse_config</code> 函数的改进。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption>Listing 12-6: Refactoring <code>parse_config</code> to return an instance of a <code>Config</code> struct</figcaption>
</figure>
<p data-x-en="We’ve added a struct named Config defined to have fields named query and file_path. The signature of parse_config now indicates that it returns a Config value. In the body of parse_config, where we used to return string slices that reference String values in args, we now define Config to contain owned String values. The args variable in main is the owner of the argument values and is only letting the parse_config function borrow them, which means we’d violate Rust’s borrowing rules if Config tried to take ownership of the values in args.">我们添加了一个名为 <code>Config</code> 的结构体，定义为具有名为 <code>query</code> 和 <code>file_path</code> 的字段。现在 <code>parse_config</code> 的签名表明它返回一个 <code>Config</code> 值。在 <code>parse_config</code> 的主体中，我们以前返回的是引用 <code>args</code> 中 <code>String</code> 值的字符串切片，现在我们定义 <code>Config</code> 包含拥有 <code>String</code> 值。在 <code>main</code> 中的 <code>args</code> 变量是参数值的所有者，只是让 <code>parse_config</code> 函数借用它们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权，我们将违反 Rust 的借用规则。</p>
<p data-x-en="There are a number of ways we could manage the String data; the easiest, though somewhat inefficient, route is to call the clone method on the values. This will make a full copy of the data for the Config instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don’t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.">我们可以用多种方式管理<code>String</code>数据；最简单但效率较低的方法是对值调用<code>clone</code>方法。这将为<code>Config</code>实例拥有数据制作一个完整的副本，这比存储字符串数据的引用需要更多的时间和内存。然而，克隆数据也使我们的代码非常直接，因为我们不必管理引用的生命周期；在这种情况下，为了获得简单性而放弃一点性能是值得的。</p>
<section class="note" aria-role="note">
<h3 id="the-trade-offs-of-using-clone"><a class="header" href="#the-trade-offs-of-using-clone">使用<code>clone</code>的权衡</a></h3>
<p data-x-en="There’s a tendency among many Rustaceans to avoid using clone to fix ownership problems because of its runtime cost. In Chapter 13, you’ll learn how to use more efficient methods in this type of situation. But for now, it’s okay to copy a few strings to continue making progress because you’ll make these copies only once and your file path and query string are very small. It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it’ll be easier to start with the most efficient solution, but for now, it’s perfectly acceptable to call clone.">许多 Rustaceans 有避免使用 <code>clone</code> 来解决所有权问题的倾向，因为它的运行时成本。在
<a href="ch13-00-functional-features.html">第 13 章</a><!-- ignore -->，你将学习如何在这种情况下使用更高效的方法。但目前，为了继续取得进展，复制一些字符串是可以的，因为这些复制只会进行一次，而且你的文件路径和查询字符串非常小。拥有一个略显低效但能正常工作的程序，总比在第一次编写时就试图过度优化代码要好。随着你对 Rust 的熟练度提高，从最高效的解决方案开始会变得更加容易，但目前，调用 <code>clone</code> 是完全可以接受的。</p>
</section>
<p data-x-en="We’ve updated main so it places the instance of Config returned by parse_config into a variable named config, and we updated the code that previously used the separate query and file_path variables so it now uses the fields on the Config struct instead.">我们已经更新了<code>main</code>，使其将<code>parse_config</code>返回的<code>Config</code>实例放入名为<code>config</code>的变量中，并且我们更新了之前使用单独的<code>query</code>和<code>file_path</code>变量的代码，现在改用<code>Config</code>结构体的字段。</p>
<p data-x-en="Now our code more clearly conveys that query and file_path are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the config instance in the fields named for their purpose.">现在我们的代码更清楚地传达了<code>query</code>和<code>file_path</code>是相关的，并且它们的目的是配置程序如何工作。使用这些值的任何代码都知道在名为其目的的<code>config</code>实例字段中找到它们。</p>
<h4 id="creating-a-constructor-for-config"><a class="header" href="#creating-a-constructor-for-config">Creating a Constructor for <code>Config</code></a></h4>
<p data-x-en="So far, we’ve extracted the logic responsible for parsing the command line arguments from main and placed it in the parse_config function. Doing so helped us see that the query and file_path values were related, and that relationship should be conveyed in our code. We then added a Config struct to name the related purpose of query and file_path and to be able to return the values’ names as struct field names from the parse_config function.">到目前为止，我们已经从<code>main</code>中提取了负责解析命令行参数的逻辑，并将其放在<code>parse_config</code>函数中。这样做帮助我们看到<code>query</code>和<code>file_path</code>值是相关的，并且这种关系应该在我们的代码中体现出来。然后我们添加了一个<code>Config</code>结构体来命名<code>query</code>和<code>file_path</code>的相关用途，并能够从<code>parse_config</code>函数返回这些值的名称作为结构体字段名称。</p>
<p data-x-en="So now that the purpose of the parse_config function is to create a Config instance, we can change parse_config from a plain function to a function named new that is associated with the Config struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as String, by calling String::new. Similarly, by changing parse_config into a new function associated with Config, we’ll be able to create instances of Config by calling Config::new. Listing 12-7 shows the changes we need to make.">所以现在<code>parse_config</code>函数的目的是创建一个<code>Config</code>实例，我们可以将<code>parse_config</code>从一个普通函数改为与<code>Config</code>结构体关联的名为<code>new</code>的函数。这样会使代码更加符合惯用法。我们可以调用<code>String::new</code>来创建标准库中的类型（如<code>String</code>）的实例。同样，通过将<code>parse_config</code>改为与<code>Config</code>关联的<code>new</code>函数，我们将能够通过调用<code>Config::new</code>来创建<code>Config</code>的实例。列表12-7显示了我们需要进行的更改。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption>Listing 12-7: Changing <code>parse_config</code> into <code>Config::new</code></figcaption>
</figure>
<p data-x-en="We’ve updated main where we were calling parse_config to instead call Config::new. We’ve changed the name of parse_config to new and moved it within an impl block, which associates the new function with Config. Try compiling this code again to make sure it works.">我们已经更新了<code>main</code>，将调用<code>parse_config</code>改为调用<code>Config::new</code>。我们将<code>parse_config</code>的名称更改为<code>new</code>，并将其移动到一个<code>impl</code>块内，这将<code>new</code>函数与<code>Config</code>关联起来。再次尝试编译这段代码，确保它能正常工作。</p>
<h3 id="fixing-the-error-handling"><a class="header" href="#fixing-the-error-handling">修复错误处理</a></h3>
<p data-x-en="Now we’ll work on fixing our error handling. Recall that attempting to access the values in the args vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:">现在我们将致力于修复错误处理。回想一下，尝试访问 <code>args</code> 向量中索引 1 或索引 2 的值如果向量包含的元素少于三个，程序将会崩溃。尝试在不带任何参数的情况下运行程序；它将如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p data-x-en="The line index out of bounds: the len is 1 but the index is 1 is an error message intended for programmers. It won’t help our end users understand what they should do instead. Let’s fix that now.">行 <code>index out of bounds: the len is 1 but the index is 1</code> 是一条面向程序员的错误消息。它不会帮助我们的最终用户理解他们应该怎么做。现在让我们来修复这个问题。</p>
<h4 id="improving-the-error-message"><a class="header" href="#improving-the-error-message">Improving the Error Message</a></h4>
<p data-x-en="In Listing 12-8, we add a check in the new function that will verify that the slice is long enough before accessing index 1 and index 2. If the slice isn’t long enough, the program panics and displays a better error message.">在清单 12-8 中，我们在 <code>new</code> 函数中添加了一个检查，以验证切片在访问索引 1 和索引 2 之前是否足够长。如果切片不够长，程序会崩溃并显示更好的错误消息。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-8: Adding a check for the number of arguments</figcaption>
</figure>
<p data-x-en="This code is similar to the Guess::new function we wrote in Listing 9-13, where we called panic! when the value argument was out of the range of valid values. Instead of checking for a range of values here, we’re checking that the length of args is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If args has fewer than three items, this condition will be true, and we call the panic! macro to end the program immediately.">这段代码类似于<a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">我们在清单 9-13 中编写的 <code>Guess::new</code> 函数</a><!-- ignore -->，当时我们在 <code>value</code> 参数超出有效值范围时调用了 <code>panic!</code>。这里我们不是检查值的范围，而是检查 <code>args</code> 的长度是否至少为 <code>3</code>，并且函数的其余部分可以假设这个条件已经满足。如果 <code>args</code> 的项少于三个，这个条件将为 <code>true</code>，我们将调用 <code>panic!</code> 宏立即终止程序。</p>
<p data-x-en="With these extra few lines of code in new, let’s run the program without any arguments again to see what the error looks like now:">在 <code>new</code> 中添加了这几行代码后，让我们再次在不带任何参数的情况下运行程序，看看现在的错误信息是什么样的：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p data-x-en="This output is better: we now have a reasonable error message. However, we also have extraneous information we don’t want to give to our users. Perhaps the technique we used in Listing 9-13 isn’t the best one to use here: a call to panic! is more appropriate for a programming problem than a usage problem, as discussed in Chapter 9. Instead, we’ll use the other technique you learned about in Chapter 9—returning a Result that indicates either success or an error.">这个输出更好：我们现在有一个合理的错误消息。然而，我们也有不想提供给用户的多余信息。也许我们在清单9-13中使用的技术在这里并不是最好的：<code>panic!</code>调用更适合于编程问题而不是使用问题，<a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">正如第9章中讨论的那样</a><!-- ignore -->。相反，我们将使用你在第9章中学到的另一种技术—<a href="ch09-02-recoverable-errors-with-result.html">返回一个<code>Result</code></a><!-- ignore -->，它表示成功或错误。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="returning-a-result-instead-of-calling-panic"><a class="header" href="#returning-a-result-instead-of-calling-panic">Returning a <code>Result</code> Instead of Calling <code>panic!</code></a></h4>
<p data-x-en="We can instead return a Result value that will contain a Config instance in the successful case and will describe the problem in the error case. We’re also going to change the function name from new to build because many programmers expect new functions to never fail. When Config::build is communicating to main, we can use the Result type to signal there was a problem. Then we can change main to convert an Err variant into a more practical error for our users without the surrounding text about thread 'main' and RUST_BACKTRACE that a call to panic! causes.">我们可以返回一个<code>Result</code>值，在成功的情况下包含一个<code>Config</code>实例，在错误的情况下描述问题。我们还将把函数名从<code>new</code>改为<code>build</code>，因为许多程序员期望<code>new</code>函数永远不会失败。当<code>Config::build</code>与<code>main</code>通信时，我们可以使用<code>Result</code>类型来信号有问题。然后我们可以更改<code>main</code>，将<code>Err</code>变体转换为对用户更实用的错误，而不会包含<code>panic!</code>调用引起的关于<code>thread 'main'</code>和<code>RUST_BACKTRACE</code>的周围文本。</p>
<p data-x-en="Listing 12-9 shows the changes we need to make to the return value of the function we’re now calling Config::build and the body of the function needed to return a Result. Note that this won’t compile until we update main as well, which we’ll do in the next listing.">列表 12-9 显示了我们需要对现在称为 <code>Config::build</code> 的函数的返回值以及为了返回一个 <code>Result</code> 所需的函数体进行的更改。请注意，直到我们更新 <code>main</code> 之前，这将无法编译，我们将在下一个列表中进行更新。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption>Listing 12-9: Returning a <code>Result</code> from <code>Config::build</code></figcaption>
</figure>
<p data-x-en="Our build function returns a Result with a Config instance in the success case and a string literal in the error case. Our error values will always be string literals that have the 'static lifetime.">我们的 <code>build</code> 函数在成功时返回一个包含 <code>Config</code> 实例的 <code>Result</code>，在错误时返回一个字符串字面量。我们的错误值将始终是具有 <code>'static</code> 生命周期的字符串字面量。</p>
<p data-x-en="We’ve made two changes in the body of the function: instead of calling panic! when the user doesn’t pass enough arguments, we now return an Err value, and we’ve wrapped the Config return value in an Ok. These changes make the function conform to its new type signature.">我们在函数体中做了两个更改：当用户没有传递足够的参数时，我们现在返回一个<code>Err</code>值，而不是调用<code>panic!</code>，并且我们将<code>Config</code>返回值包装在<code>Ok</code>中。这些更改使函数符合其新的类型签名。</p>
<p data-x-en="Returning an Err value from Config::build allows the main function to handle the Result value returned from the build function and exit the process more cleanly in the error case.">从 <code>Config::build</code> 返回一个 <code>Err</code> 值允许 <code>main</code> 函数处理从 <code>build</code> 函数返回的 <code>Result</code> 值，并在错误情况下更干净地退出进程。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="calling-configbuild-and-handling-errors"><a class="header" href="#calling-configbuild-and-handling-errors">Calling <code>Config::build</code> and Handling Errors</a></h4>
<p data-x-en="To handle the error case and print a user-friendly message, we need to update main to handle the Result being returned by Config::build, as shown in Listing 12-10. We’ll also take the responsibility of exiting the command line tool with a nonzero error code away from panic! and instead implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.">为了处理错误情况并打印用户友好的消息，我们需要更新<code>main</code>以处理<code>Config::build</code>返回的<code>Result</code>，如清单12-10所示。我们还将从<code>panic!</code>中移除以非零错误代码退出命令行工具的责任，而是手动实现它。非零退出状态是一种惯例，用于向调用我们程序的进程发出信号，表示程序以错误状态退出。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-10: Exiting with an error code if building a <code>Config</code> fails</figcaption>
</figure>
<p data-x-en="In this listing, we’ve used a method we haven’t covered in detail yet: unwrap_or_else, which is defined on Result<T, E> by the standard library. Using unwrap_or_else allows us to define some custom, non-panic! error handling. If the Result is an Ok value, this method’s behavior is similar to unwrap: it returns the inner value that Ok is wrapping. However, if the value is an Err value, this method calls the code in the closure, which is an anonymous function we define and pass as an argument to unwrap_or_else. We’ll cover closures in more detail in Chapter 13. For now, you just need to know that unwrap_or_else will pass the inner value of the Err, which in this case is the static string &quot;not enough arguments&quot; that we added in Listing 12-9, to our closure in the argument err that appears between the vertical pipes. The code in the closure can then use the err value when it runs.">在本示例中，我们使用了一个尚未详细讨论的方法：<code>unwrap_or_else</code>，这是标准库在<code>Result&lt;T, E&gt;</code> 上定义的。
使用 <code>unwrap_or_else</code> 可以让我们定义一些自定义的、非-<code>panic!</code> 错误处理。如果 <code>Result</code> 是一个 <code>Ok</code> 值，此方法的行为类似于 <code>unwrap</code>：它返回 <code>Ok</code> 包装的内部值。然而，如果值是一个 <code>Err</code> 值，此方法将调用 <em>闭包</em> 中的代码，这是一个我们定义并作为参数传递给 <code>unwrap_or_else</code> 的匿名函数。
我们将在 <a href="ch13-00-functional-features.html">第 13 章</a><!-- ignore --> 中更详细地讨论闭包。目前，您只需要知道 <code>unwrap_or_else</code> 会将 <code>Err</code> 的内部值，即我们在清单 12-9 中添加的静态字符串 <code>"not enough arguments"</code>，传递给闭包中的参数 <code>err</code>，该参数出现在竖线之间。闭包中的代码在运行时可以使用 <code>err</code> 值。</p>
<p data-x-en="We’ve added a new use line to bring process from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the err value and then call process::exit. The process::exit function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the panic!-based handling we used in Listing 12-8, but we no longer get all the extra output. Let’s try it:">我们添加了一行新的<code>use</code>，将标准库中的<code>process</code>引入作用域。闭包中在错误情况下将运行的代码只有两行：我们打印<code>err</code>值，然后调用<code>process::exit</code>。<code>process::exit</code>函数会立即停止程序，并返回作为退出状态码传递的数字。这类似于我们在列表12-8中使用的基于<code>panic!</code>的处理方式，但我们不再获得所有额外的输出。让我们试一试：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p data-x-en="Great! This output is much friendlier for our users.">很好！这个输出对我们的用户更加友好。</p>
<h3 id="extracting-logic-from-main"><a class="header" href="#extracting-logic-from-main">从 <code>main</code> 中提取逻辑</a></h3>
<p data-x-en="Now that we’ve finished refactoring the configuration parsing, let’s turn to the program’s logic. As we stated in “Separation of Concerns for Binary Projects”, we’ll extract a function named run that will hold all the logic currently in the main function that isn’t involved with setting up configuration or handling errors. When we’re done, main will be concise and easy to verify by inspection, and we’ll be able to write tests for all the other logic.">现在我们已经完成了配置解析的重构，让我们转向程序的逻辑。正如我们在<a href="#separation-of-concerns-for-binary-projects">“二进制项目中的关注点分离”</a><!-- ignore -->中所述，我们将提取一个名为<code>run</code>的函数，该函数将包含当前在<code>main</code>函数中与设置配置或处理错误无关的所有逻辑。完成后，<code>main</code>将变得简洁且易于通过检查验证，我们还将能够为所有其他逻辑编写测试。</p>
<p data-x-en="Listing 12-11 shows the extracted run function. For now, we’re just making the small, incremental improvement of extracting the function. We’re still defining the function in src/main.rs.">列表 12-11 显示了提取的 <code>run</code> 函数。目前，我们只是做了提取函数这一小的、逐步的改进。我们仍然在 <em>src/main.rs</em> 中定义该函数。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-11: Extracting a <code>run</code> function containing the rest of the program logic</figcaption>
</figure>
<p data-x-en="The run function now contains all the remaining logic from main, starting from reading the file. The run function takes the Config instance as an argument."><code>run</code> 函数现在包含了来自 <code>main</code> 的所有剩余逻辑，从读取文件开始。<code>run</code> 函数接受 <code>Config</code> 实例作为参数。</p>
<h4 id="returning-errors-from-the-run-function"><a class="header" href="#returning-errors-from-the-run-function">Returning Errors from the <code>run</code> Function</a></h4>
<p data-x-en="With the remaining program logic separated into the run function, we can improve the error handling, as we did with Config::build in Listing 12-9. Instead of allowing the program to panic by calling expect, the run function will return a Result<T, E> when something goes wrong. This will let us further consolidate the logic around handling errors into main in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of run.">随着剩余的程序逻辑被分离到 <code>run</code> 函数中，我们可以改进错误处理，就像我们在清单 12-9 中对 <code>Config::build</code> 所做的那样。而不是通过调用 <code>expect</code> 使程序 panic，<code>run</code> 函数将在出现问题时返回一个 <code>Result&lt;T, E&gt;</code>。这将使我们能够进一步将错误处理逻辑整合到 <code>main</code> 中，以一种用户友好的方式。清单 12-12 显示了我们需要对 <code>run</code> 的签名和主体进行的更改。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-12: Changing the <code>run</code> function to return <code>Result</code></figcaption>
</figure>
<p data-x-en="We’ve made three significant changes here. First, we changed the return type of the run function to Result<(), Box<dyn Error>>. This function previously returned the unit type, (), and we keep that as the value returned in the Ok case.">我们在这里做了三个重要的更改。首先，我们将 <code>run</code> 函数的返回类型更改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。此函数之前返回单元类型 <code>()</code>，我们保持在 <code>Ok</code> 情况下返回的值不变。</p>
<p data-x-en="For the error type, we used the trait object Box<dyn Error> (and we’ve brought std::error::Error into scope with a use statement at the top). We’ll cover trait objects in Chapter 18. For now, just know that Box<dyn Error> means the function will return a type that implements the Error trait, but we don’t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The dyn keyword is short for dynamic.">对于错误类型，我们使用了<em>trait 对象</em> <code>Box&lt;dyn Error&gt;</code>（并且我们通过顶部的 <code>use</code> 语句将 <code>std::error::Error</code> 引入了作用域）。
我们将在<a href="ch18-00-oop.html">第 18 章</a><!-- ignore -->中介绍 trait 对象。目前，只需知道 <code>Box&lt;dyn Error&gt;</code> 意味着函数将返回一个实现了 <code>Error</code> trait 的类型，但不必指定返回值的具体类型。这使我们能够在不同的错误情况下返回可能不同类型的错误值。<code>dyn</code> 关键字是 <em>动态</em> 的缩写。</p>
<p data-x-en="Second, we’ve removed the call to expect in favor of the ? operator, as we talked about in Chapter 9. Rather than panic! on an error, ? will return the error value from the current function for the caller to handle.">其次，我们移除了对 <code>expect</code> 的调用，转而使用 <code>?</code> 操作符，正如我们在 <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">第 9 章</a><!-- ignore --> 中讨论的那样。遇到错误时，<code>?</code> 不会 <code>panic!</code>，而是将错误值从当前函数返回给调用者处理。</p>
<p data-x-en="Third, the run function now returns an Ok value in the success case. We’ve declared the run function’s success type as () in the signature, which means we need to wrap the unit type value in the Ok value. This Ok(()) syntax might look a bit strange at first, but using () like this is the idiomatic way to indicate that we’re calling run for its side effects only; it doesn’t return a value we need.">第三，<code>run</code> 函数现在在成功情况下返回一个 <code>Ok</code> 值。
我们已经在签名中声明 <code>run</code> 函数的成功类型为 <code>()</code>，
这意味着我们需要将单元类型值包装在 <code>Ok</code> 值中。这
<code>Ok(())</code> 语法一开始可能看起来有点奇怪，但这样使用 <code>()</code>
是惯用的方式，表示我们调用 <code>run</code> 只是为了它的副作用；
它没有返回我们需要的值。</p>
<p data-x-en="When you run this code, it will compile but will display a warning:">当你运行这段代码时，它会编译但会显示一个警告：</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p data-x-en="Rust tells us that our code ignored the Result value and the Result value might indicate that an error occurred. But we’re not checking to see whether or not there was an error, and the compiler reminds us that we probably meant to have some error-handling code here! Let’s rectify that problem now.">Rust 告诉我们，我们的代码忽略了 <code>Result</code> 值，而 <code>Result</code> 值
可能表示发生了错误。但我们没有检查是否发生了错误，编译器提醒我们，我们可能打算在这里有一些错误处理代码！现在让我们纠正这个问题。</p>
<h4 id="handling-errors-returned-from-run-in-main"><a class="header" href="#handling-errors-returned-from-run-in-main">Handling Errors Returned from <code>run</code> in <code>main</code></a></h4>
<p data-x-en="We’ll check for errors and handle them using a technique similar to one we used with Config::build in Listing 12-10, but with a slight difference:">我们将检查错误并使用类似于我们在清单 12-10 中使用 <code>Config::build</code> 的技术来处理它们，但有一点不同：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p data-x-en="We use if let rather than unwrap_or_else to check whether run returns an Err value and to call process::exit(1) if it does. The run function doesn’t return a value that we want to unwrap in the same way that Config::build returns the Config instance. Because run returns () in the success case, we only care about detecting an error, so we don’t need unwrap_or_else to return the unwrapped value, which would only be ().">我们使用<code>if let</code>而不是<code>unwrap_or_else</code>来检查<code>run</code>是否返回一个<code>Err</code>值，并在返回<code>Err</code>时调用<code>process::exit(1)</code>。<code>run</code>函数不会返回我们像<code>Config::build</code>返回<code>Config</code>实例那样需要<code>unwrap</code>的值。因为<code>run</code>在成功情况下返回<code>()</code>，我们只关心检测错误，所以不需要<code>unwrap_or_else</code>来返回解包的值，这个值只会是<code>()</code>。</p>
<p data-x-en="The bodies of the if let and the unwrap_or_else functions are the same in both cases: we print the error and exit."><code>if let</code> 和 <code>unwrap_or_else</code> 函数的主体在这两种情况下是相同的：我们打印错误并退出。</p>
<h3 id="splitting-code-into-a-library-crate"><a class="header" href="#splitting-code-into-a-library-crate">将代码拆分为库包</a></h3>
<p data-x-en="Our minigrep project is looking good so far! Now we’ll split the src/main.rs file and put some code into the src/lib.rs file. That way, we can test the code and have a src/main.rs file with fewer responsibilities.">我们的 <code>minigrep</code> 项目到目前为止看起来不错！现在我们将拆分 <em>src/main.rs</em> 文件，并将一些代码放入 <em>src/lib.rs</em> 文件中。这样，我们可以测试代码，并且有一个职责更少的 <em>src/main.rs</em> 文件。</p>
<p data-x-en="Let’s move all the code that isn’t in the main function from src/main.rs to src/lib.rs:">让我们将不在 <code>main</code> 函数中的所有代码从 <em>src/main.rs</em> 移动到 <em>src/lib.rs</em>：</p>
<ul>
<li data-x-en="The run function definition"><code>run</code> 函数定义</li>
<li data-x-en="The relevant use statements">相关的 <code>use</code> 语句</li>
<li data-x-en="The definition of Config"><code>Config</code> 的定义</li>
<li data-x-en="The Config::build function definition"><code>Config::build</code> 函数定义</li>
</ul>
<p data-x-en="The contents of src/lib.rs should have the signatures shown in Listing 12-13 (we’ve omitted the bodies of the functions for brevity). Note that this won’t compile until we modify src/main.rs in Listing 12-14."><em>src/lib.rs</em> 的内容应该具有如清单 12-13 所示的签名（我们为了简洁起见省略了函数的主体）。请注意，直到我们在清单 12-14 中修改 <em>src/main.rs</em> 之前，这不会编译。</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<figcaption>Listing 12-13: Moving <code>Config</code> and <code>run</code> into <em>src/lib.rs</em></figcaption>
</figure>
<p data-x-en="We’ve made liberal use of the pub keyword: on Config, on its fields and its build method, and on the run function. We now have a library crate that has a public API we can test!">我们大量使用了 <code>pub</code> 关键字：在 <code>Config</code> 上，在其字段和其 <code>build</code> 方法上，以及在 <code>run</code> 函数上。我们现在有一个具有可以测试的公共 API 的库 crate！</p>
<p data-x-en="Now we need to bring the code we moved to src/lib.rs into the scope of the binary crate in src/main.rs, as shown in Listing 12-14.">现在我们需要将移动到<em>src/lib.rs</em>的代码引入<em>src/main.rs</em>中二进制包的作用域，如清单12-14所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<figcaption>Listing 12-14: Using the <code>minigrep</code> library crate in <em>src/main.rs</em></figcaption>
</figure>
<p data-x-en="We add a use minigrep::Config line to bring the Config type from the library crate into the binary crate’s scope, and we prefix the run function with our crate name. Now all the functionality should be connected and should work. Run the program with cargo run and make sure everything works correctly.">我们添加了一行<code>use minigrep::Config</code>，将<code>Config</code>类型从库crate引入到二进制crate的作用域中，并且我们在<code>run</code>函数前加上了crate名称。现在所有功能都应该连接起来并且可以工作。使用<code>cargo run</code>运行程序，并确保一切正常工作。</p>
<p data-x-en="Whew! That was a lot of work, but we’ve set ourselves up for success in the future. Now it’s much easier to handle errors, and we’ve made the code more modular. Almost all of our work will be done in src/lib.rs from here on out.">呼！这是一项艰巨的工作，但我们已经为未来的成功奠定了基础。现在处理错误变得更加容易，而且我们使代码更加模块化。从现在开始，我们几乎所有的工件都将在<em>src/lib.rs</em>中完成。</p>
<p data-x-en="Let’s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we’ll write some tests!">让我们利用这种新获得的模块化特性来做一些在旧代码中很难但在新代码中很容易的事情：我们将编写一些测试！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>