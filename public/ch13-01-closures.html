<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>闭包：捕获其环境的匿名函数 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch13-01-closures.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closures-anonymous-functions-that-capture-their-environment"><a class="header" href="#closures-anonymous-functions-that-capture-their-environment">闭包：捕获其环境的匿名函数</a></h2>
<p data-x-en="Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.">Rust 的闭包是你可以保存在变量中或作为参数传递给其他函数的匿名函数。你可以在一个地方创建闭包，然后在其他地方调用闭包以在不同的上下文中进行评估。与函数不同，闭包可以捕获其定义范围内 的值。我们将演示这些闭包特性如何允许代码重用和行为定制。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">使用闭包捕获环境</a></h3>
<p data-x-en="We’ll first examine how we can use closures to capture values from the environment they’re defined in for later use. Here’s the scenario: Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn’t specified a favorite color, they get whatever color the company currently has the most of.">我们首先看看如何使用闭包来捕获它们定义环境中的值以供稍后使用。这是一个场景：我们的T恤公司偶尔会向我们邮件列表中的某人赠送一款独家限量版T恤作为促销。邮件列表中的人可以选择将他们最喜欢的颜色添加到他们的个人资料中。如果被选中免费获得T恤的人设置了他们最喜欢的颜色，他们就会得到那种颜色的T恤。如果这个人没有指定最喜欢的颜色，他们就会得到公司目前库存最多的那种颜色。</p>
<p data-x-en="There are many ways to implement this. For this example, we’re going to use an enum called ShirtColor that has the variants Red and Blue (limiting the number of colors available for simplicity). We represent the company’s inventory with an Inventory struct that has a field named shirts that contains a Vec<ShirtColor> representing the shirt colors currently in stock. The method giveaway defined on Inventory gets the optional shirt color preference of the free shirt winner, and returns the shirt color the person will get. This setup is shown in Listing 13-1:">有许多方法可以实现这一点。对于这个例子，我们将使用一个名为 <code>ShirtColor</code> 的枚举，它有 <code>Red</code> 和 <code>Blue</code> 两个变体（为了简化，限制了可用的颜色数量）。我们用一个名为 <code>Inventory</code> 的结构体来表示公司的库存，该结构体有一个名为 <code>shirts</code> 的字段，其中包含一个 <code>Vec&lt;ShirtColor&gt;</code>，表示当前库存中的衬衫颜色。定义在 <code>Inventory</code> 上的 <code>giveaway</code> 方法获取免费衬衫获奖者可选的衬衫颜色，并返回该人将获得的衬衫颜色。这个设置如清单 13-1 所示：</p>
<figure class="listing" id="listing-13-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
<figcaption><a href="#listing-13-1">Listing 13-1</a>: Shirt company giveaway situation</figcaption>
</figure>
<p data-x-en="The store defined in main has two blue shirts and one red shirt remaining to distribute for this limited-edition promotion. We call the giveaway method for a user with a preference for a red shirt and a user without any preference.">在 <code>main</code> 中定义的 <code>store</code> 还剩下两件蓝色衬衫和一件红色衬衫可以分发给这次限量版促销活动。我们为一个偏好红色衬衫的用户和一个没有特定偏好的用户调用 <code>giveaway</code> 方法。</p>
<p data-x-en="Again, this code could be implemented in many ways, and here, to focus on closures, we’ve stuck to concepts you’ve already learned, except for the body of the giveaway method that uses a closure. In the giveaway method, we get the user preference as a parameter of type Option<ShirtColor> and call the unwrap_or_else method on user_preference. The unwrap_or_else method on Option<T> is defined by the standard library. It takes one argument: a closure without any arguments that returns a value T (the same type stored in the Some variant of the Option<T>, in this case ShirtColor). If the Option<T> is the Some variant, unwrap_or_else returns the value from within the Some. If the Option<T> is the None variant, unwrap_or_else calls the closure and returns the value returned by the closure.">同样，这段代码可以以多种方式实现，这里为了专注于闭包，我们坚持使用你已经学过的概念，除了<code>giveaway</code>方法的主体部分使用了闭包。在<code>giveaway</code>方法中，我们获取用户偏好作为类型为<code>Option&lt;ShirtColor&gt;</code>的参数，并在<code>user_preference</code>上调用<code>unwrap_or_else</code>方法。<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else" target="_blank"><code>Option&lt;T&gt;</code>上的<code>unwrap_or_else</code>方法</a><!-- ignore -->是由标准库定义的。它接受一个参数：一个不带任何参数的闭包，该闭包返回一个值<code>T</code>（与<code>Option&lt;T&gt;</code>中的<code>Some</code>变体存储的类型相同，在这种情况下为<code>ShirtColor</code>）。如果<code>Option&lt;T&gt;</code>是<code>Some</code>变体，<code>unwrap_or_else</code>返回<code>Some</code>中的值。如果<code>Option&lt;T&gt;</code>是<code>None</code>变体，<code>unwrap_or_else</code>调用闭包并返回闭包返回的值。</p>
<p data-x-en="We specify the closure expression || self.most_stocked() as the argument to unwrap_or_else. This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical bars). The body of the closure calls self.most_stocked(). We’re defining the closure here, and the implementation of unwrap_or_else will evaluate the closure later if the result is needed.">我们指定闭包表达式 <code>|| self.most_stocked()</code> 作为 <code>unwrap_or_else</code> 的参数。这是一个不带参数的闭包（如果闭包有参数，它们会出现在两个竖线之间）。闭包的主体调用 <code>self.most_stocked()</code>。我们在这里定义闭包，<code>unwrap_or_else</code> 的实现将在需要结果时稍后评估闭包。</p>
<p data-x-en="Running this code prints:">运行此代码会打印：</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p data-x-en="One interesting aspect here is that we’ve passed a closure that calls self.most_stocked() on the current Inventory instance. The standard library didn’t need to know anything about the Inventory or ShirtColor types we defined, or the logic we want to use in this scenario. The closure captures an immutable reference to the self Inventory instance and passes it with the code we specify to the unwrap_or_else method. Functions, on the other hand, are not able to capture their environment in this way.">一个有趣的方面是我们传递了一个闭包，该闭包在当前的<code>Inventory</code>实例上调用了<code>self.most_stocked()</code>。标准库并不需要了解我们定义的<code>Inventory</code>或<code>ShirtColor</code>类型，也不需要了解在这种情况下我们想要使用的逻辑。闭包捕获了一个对<code>self</code> <code>Inventory</code>实例的不可变引用，并将其与我们指定的代码一起传递给<code>unwrap_or_else</code>方法。然而，函数并不能以这种方式捕获其环境。</p>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">闭包类型推断和注解</a></h3>
<p data-x-en="There are more differences between functions and closures. Closures don’t usually require you to annotate the types of the parameters or the return value like fn functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.">函数和闭包之间还有更多的区别。闭包通常不需要像 <code>fn</code> 函数那样标注参数或返回值的类型。函数需要类型注解，因为类型是暴露给用户的一个显式接口的一部分。严格定义这个接口对于确保每个人都同意函数使用和返回的值的类型非常重要。另一方面，闭包不会在这种暴露的接口中使用：它们存储在变量中，不命名也不向我们的库的用户暴露。</p>
<p data-x-en="Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).">闭包通常很短，并且只在狭窄的上下文中相关，而不是在任何任意场景中。在这些有限的上下文中，编译器可以推断参数和返回类型的类型，类似于它能够推断大多数变量的类型（有少数情况下编译器也需要闭包类型注解）。</p>
<p data-x-en="As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we’re defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument as we did in Listing 13-1.">与变量一样，如果我们要以增加冗余为代价来提高明确性和清晰度，可以添加类型注解。为闭包注解类型看起来像示例 13-2 中的定义。在这个例子中，我们定义了一个闭包并将其存储在一个变量中，而不是像在示例 13-1 中那样在传递闭包作为参数的地方定义闭包。</p>
<figure class="listing" id="listing-13-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-13-2">Listing 13-2</a>: Adding optional type annotations of the parameter and return value types in the closure</figcaption>
</figure>
<p data-x-en="With type annotations added, the syntax of closures looks more similar to the syntax of functions. Here we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We’ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:">添加了类型注解后，闭包的语法看起来更接近函数的语法。这里我们定义了一个将其参数加1的函数和一个具有相同行为的闭包，以便进行比较。我们添加了一些空格以对齐相关部分。这说明了闭包的语法与函数的语法相似，除了使用管道符号和可选语法的数量：</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p data-x-en="The first line shows a function definition, and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they’re called. The add_one_v3 and add_one_v4 lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to let v = Vec::new(); needing either type annotations or values of some type to be inserted into the Vec for Rust to be able to infer the type.">第一行显示了一个函数定义，第二行显示了一个完全注解的闭包定义。在第三行，我们从闭包定义中移除了类型注解。在第四行，我们移除了括号，因为闭包体只有一个表达式，所以括号是可选的。这些都是有效的定义，当它们被调用时会产生相同的行为。<code>add_one_v3</code> 和 <code>add_one_v4</code> 行需要闭包被评估才能编译，因为类型将从它们的使用中推断出来。这类似于 <code>let v = Vec::new();</code> 需要类型注解或插入到 <code>Vec</code> 中的某些类型的值，以便 Rust 能够推断类型。</p>
<p data-x-en="For closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn’t very useful except for the purposes of this example. Note that we haven’t added any type annotations to the definition. Because there are no type annotations, we can call the closure with any type, which we’ve done here with String the first time. If we then try to call example_closure with an integer, we’ll get an error.">对于闭包定义，编译器将为它们的每个参数和返回值推断一个具体的类型。例如，列表 13-3 显示了一个简短的闭包定义，该闭包只是返回它作为参数接收的值。这个闭包除了用于这个例子之外并没有什么用处。请注意，我们没有在定义中添加任何类型注解。因为没有类型注解，我们可以用任何类型调用闭包，这里我们第一次使用 <code>String</code>。如果我们然后尝试用一个整数调用 <code>example_closure</code>，我们将得到一个错误。</p>
<figure class="listing" id="listing-13-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-13-3">Listing 13-3</a>: Attempting to call a closure whose types are inferred with two different types</figcaption>
</figure>
<p data-x-en="The compiler gives us this error:">编译器给出了这个错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p data-x-en="The first time we call example_closure with the String value, the compiler infers the type of x and the return type of the closure to be String. Those types are then locked into the closure in example_closure, and we get a type error when we next try to use a different type with the same closure.">第一次我们用 <code>String</code> 值调用 <code>example_closure</code> 时，编译器推断 <code>x</code> 和闭包的返回类型为 <code>String</code>。这些类型随后被锁定在 <code>example_closure</code> 的闭包中，当我们下次尝试使用不同类型的相同闭包时，会得到类型错误。</p>
<h3 id="capturing-references-or-moving-ownership"><a class="header" href="#capturing-references-or-moving-ownership">捕获引用或转移所有权</a></h3>
<p data-x-en="Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.">闭包可以通过三种方式从其环境捕获值，这直接对应于函数接受参数的三种方式：不可变借用、可变借用和获取所有权。闭包将根据函数体对捕获值的处理方式来决定使用其中的哪一种。</p>
<p data-x-en="In Listing 13-4, we define a closure that captures an immutable reference to the vector named list because it only needs an immutable reference to print the value:">在清单 13-4 中，我们定义了一个捕获对名为 <code>list</code> 的向量的不可变引用的闭包，因为它只需要一个不可变引用来打印值：</p>
<figure class="listing" id="listing-13-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-4">Listing 13-4</a>: Defining and calling a closure that captures an immutable reference</figcaption>
</figure>
<p data-x-en="This example also illustrates that a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.">这个例子还说明了一个变量可以绑定到闭包定义，我们可以通过使用变量名和括号来调用闭包，就像变量名是一个函数名一样。</p>
<p data-x-en="Because we can have multiple immutable references to list at the same time, list is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called. This code compiles, runs, and prints:">因为我们可以同时拥有 <code>list</code> 的多个不可变引用，<code>list</code> 仍然可以在闭包定义之前的代码中访问，在闭包定义之后但闭包被调用之前访问，以及在闭包被调用之后访问。这段代码可以编译、运行并打印：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p data-x-en="Next, in Listing 13-5, we change the closure body so that it adds an element to the list vector. The closure now captures a mutable reference:">接下来，在清单 13-5 中，我们更改闭包体，使其向 <code>list</code> 向量添加一个元素。闭包现在捕获一个可变引用：</p>
<figure class="listing" id="listing-13-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-5">Listing 13-5</a>: Defining and calling a closure that captures a mutable reference</figcaption>
</figure>
<p data-x-en="This code compiles, runs, and prints:">这段代码编译、运行并打印：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p data-x-en="Note that there’s no longer a println! between the definition and the call of the borrows_mutably closure: when borrows_mutably is defined, it captures a mutable reference to list. We don’t use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn’t allowed because no other borrows are allowed when there’s a mutable borrow. Try adding a println! there to see what error message you get!">请注意，<code>borrows_mutably</code> 闭包的定义和调用之间不再有 <code>println!</code>：当 <code>borrows_mutably</code> 被定义时，它捕获了对 <code>list</code> 的可变引用。我们在闭包被调用后不再使用该闭包，因此可变借用结束。在闭包定义和闭包调用之间，由于存在可变借用，不允许进行不可变借用以进行打印。尝试在那里添加一个 <code>println!</code> 以查看你将得到什么错误消息！</p>
<p data-x-en="If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the move keyword before the parameter list.">如果您希望强制闭包获取其在环境中使用的值的所有权，即使闭包的主体严格来说并不需要所有权，您可以在参数列表前使用 <code>move</code> 关键字。</p>
<p data-x-en="This technique is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread. We’ll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let’s briefly explore spawning a new thread using a closure that needs the move keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread:">这种技术在将闭包传递给新线程以移动数据，使数据由新线程拥有时非常有用。我们将在第16章讨论线程以及为什么要在讨论并发时使用它们，但目前，让我们简要探讨一下使用需要<code>move</code>关键字的闭包来启动新线程。列表13-6显示了修改后的列表13-4，它在新线程中而不是主线程中打印向量：</p>
<figure class="listing" id="listing-13-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-13-6">Listing 13-6</a>: Using <code>move</code> to force the closure for the thread to take ownership of <code>list</code></figcaption>
</figure>
<p data-x-en="We spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured list using an immutable reference because that’s the least amount of access to list needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that list should be moved into the closure by putting the move keyword at the beginning of the closure definition. The new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of list but ended before the new thread did and dropped list, the immutable reference in the thread would be invalid. Therefore, the compiler requires that list be moved into the closure given to the new thread so the reference will be valid. Try removing the move keyword or using list in the main thread after the closure is defined to see what compiler errors you get!">我们创建一个新的线程，将一个闭包作为参数传递给线程。闭包体打印出列表。在清单 13-4 中，闭包只使用不可变引用捕获了 <code>list</code>，因为这是打印 <code>list</code> 所需的最少访问权限。在这个例子中，即使闭包体仍然只需要一个不可变引用，我们也需要通过在闭包定义的开头放置 <code>move</code> 关键字来指定 <code>list</code> 应该被移动到闭包中。新线程可能在主线程的其余部分完成之前结束，或者主线程可能先结束。如果主线程保持对 <code>list</code> 的所有权但在新线程之前结束并释放了 <code>list</code>，线程中的不可变引用将无效。因此，编译器要求将 <code>list</code> 移动到给新线程的闭包中，以使引用有效。尝试删除 <code>move</code> 关键字或在定义闭包后在主线程中使用 <code>list</code>，看看你会得到什么编译错误！</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moving-captured-values-out-of-closures-and-the-fn-traits"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits">将捕获的值移出闭包和 <code>Fn</code> 特性</a></h3>
<p data-x-en="Once a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved into the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved out of the closure). A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.">一旦闭包从定义闭包的环境中捕获了一个引用或捕获了值的所有权（从而影响了什么，如果有的话，被<em>移入</em>闭包），闭包体中的代码定义了在闭包稍后被求值时引用或值会发生什么（从而影响了什么，如果有的话，被<em>移出</em>闭包）。闭包体可以执行以下任何操作：将捕获的值移出闭包，修改捕获的值，既不移出也不修改值，或者从一开始就从环境中捕获任何内容。</p>
<p data-x-en="The way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these Fn traits, in an additive fashion, depending on how the closure’s body handles the values:">闭包捕获和处理环境中的值的方式会影响闭包实现哪些特质，而特质是函数和结构体指定它们可以使用什么类型的闭包的方式。闭包会根据闭包体如何处理值，自动实现这一个、两个或全部三个<code>Fn</code>特质，以累加的方式。</p>
<ol>
<li data-x-en="FnOnce applies to closures that can be called once. All closures implement at least this trait because all closures can be called. A closure that moves captured values out of its body will only implement FnOnce and none of the other Fn traits, because it can only be called once."><code>FnOnce</code> 适用于只能调用一次的闭包。所有闭包至少实现了这个特质，因为所有闭包都可以被调用。一个从其体内移出捕获值的闭包将只实现 <code>FnOnce</code> 而不实现其他任何 <code>Fn</code> 特质，因为它只能被调用一次。</li>
<li data-x-en="FnMut applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once."><code>FnMut</code> 适用于不会将其捕获的值移出其作用域的闭包，但可能会修改捕获的值。这些闭包可以被调用多次。</li>
<li data-x-en="Fn applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently."><code>Fn</code> 适用于不会将其捕获的值移出其作用域的闭包，以及不会修改其捕获的值的闭包，还包括不从其环境中捕获任何内容的闭包。这些闭包可以在不修改其环境的情况下多次调用，这在并发多次调用闭包的情况下非常重要。</li>
</ol>
<p data-x-en="Let’s look at the definition of the unwrap_or_else method on Option<T> that we used in Listing 13-1:">让我们看看我们在示例 13-1 中使用的 <code>Option&lt;T&gt;</code> 上的 <code>unwrap_or_else</code> 方法的定义：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p data-x-en="Recall that T is the generic type representing the type of the value in the Some variant of an Option. That type T is also the return type of the unwrap_or_else function: code that calls unwrap_or_else on an Option<String>, for example, will get a String.">回想 <code>T</code> 是表示 <code>Option</code> 中 <code>Some</code> 变体值类型的泛型类型。该类型 <code>T</code> 也是 <code>unwrap_or_else</code> 函数的返回类型：例如，对 <code>Option&lt;String&gt;</code> 调用 <code>unwrap_or_else</code> 的代码将获得一个 <code>String</code>。</p>
<p data-x-en="Next, notice that the unwrap_or_else function has the additional generic type parameter F. The F type is the type of the parameter named f, which is the closure we provide when calling unwrap_or_else.">接下来，注意 <code>unwrap_or_else</code> 函数具有额外的泛型类型参数 <code>F</code>。类型 <code>F</code> 是名为 <code>f</code> 的参数的类型，即我们在调用 <code>unwrap_or_else</code> 时提供的闭包。</p>
<p data-x-en="The trait bound specified on the generic type F is FnOnce() -> T, which means F must be able to be called once, take no arguments, and return a T. Using FnOnce in the trait bound expresses the constraint that unwrap_or_else is only going to call f at most one time. In the body of unwrap_or_else, we can see that if the Option is Some, f won’t be called. If the Option is None, f will be called once. Because all closures implement FnOnce, unwrap_or_else accepts all three kinds of closures and is as flexible as it can be.">指定的泛型类型 <code>F</code> 的特征约束是 <code>FnOnce() -&gt; T</code>，这意味着 <code>F</code> 必须能够被调用一次，不接受任何参数，并返回一个 <code>T</code>。在特征约束中使用 <code>FnOnce</code> 表示 <code>unwrap_or_else</code> 只会最多调用 <code>f</code> 一次。在 <code>unwrap_or_else</code> 的函数体中，我们可以看到如果 <code>Option</code> 是 <code>Some</code>，<code>f</code> 不会被调用。如果 <code>Option</code> 是 <code>None</code>，<code>f</code> 将被调用一次。因为所有闭包都实现了 <code>FnOnce</code>，<code>unwrap_or_else</code> 接受所有三种类型的闭包，并且尽可能灵活。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure. For example, we could call unwrap_or_else(Vec::new) on a Option<Vec<T>> value to get a new, empty vector if the value is None. The compiler automatically implements whichever of the Fn traits is applicable for a function definition.">注意：如果我们不需要从环境中捕获值，我们可以使用函数名而不是闭包。例如，我们可以在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 值上调用 <code>unwrap_or_else(Vec::new)</code>，如果值为 <code>None</code>，则获取一个新的空向量。编译器会自动为函数定义实现适用的 <code>Fn</code> 特性。</p>
</section>
<p data-x-en="Now let’s look at the standard library method sort_by_key defined on slices, to see how that differs from unwrap_or_else and why sort_by_key uses FnMut instead of FnOnce for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and returns a value of type K that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of Rectangle instances and we use sort_by_key to order them by their width attribute from low to high:">现在让我们看看定义在切片上的标准库方法<code>sort_by_key</code>，看看它与<code>unwrap_or_else</code>有何不同，以及为什么<code>sort_by_key</code>使用<code>FnMut</code>而不是<code>FnOnce</code>作为特质边界。闭包接收一个参数，形式为当前考虑的切片项的引用，并返回一个可以排序的类型<code>K</code>的值。当你想根据每个项的特定属性对切片进行排序时，此函数非常有用。在列表13-7中，我们有一个<code>Rectangle</code>实例列表，并使用<code>sort_by_key</code>按其<code>width</code>属性从低到高对它们进行排序：</p>
<figure class="listing" id="listing-13-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-7">Listing 13-7</a>: Using <code>sort_by_key</code> to order rectangles by width</figcaption>
</figure>
<p data-x-en="This code prints:">这段代码打印：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p data-x-en="The reason sort_by_key is defined to take an FnMut closure is that it calls the closure multiple times: once for each item in the slice. The closure |r| r.width doesn’t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements."><code>sort_by_key</code> 被定义为接受一个 <code>FnMut</code> 闭包的原因是它会多次调用该闭包：每次调用都是为了切片中的每个项目。闭包 <code>|r| r.width</code> 不会捕获、修改或从其环境中移出任何内容，因此它满足特质约束要求。</p>
<p data-x-en="In contrast, Listing 13-8 shows an example of a closure that implements just the FnOnce trait, because it moves a value out of the environment. The compiler won’t let us use this closure with sort_by_key:">相比之下，列表 13-8 显示了一个只实现了 <code>FnOnce</code> 特性的闭包示例，因为它从环境中移动了一个值。编译器不会让我们使用这个闭包与 <code>sort_by_key</code>：</p>
<figure class="listing" id="listing-13-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
<figcaption><a href="#listing-13-8">Listing 13-8</a>: Attempting to use an <code>FnOnce</code> closure with <code>sort_by_key</code></figcaption>
</figure>
<p data-x-en="This is a contrived, convoluted way (that doesn’t work) to try and count the number of times sort_by_key calls the closure when sorting list. This code attempts to do this counting by pushing value—a String from the closure’s environment—into the sort_operations vector. The closure captures value and then moves value out of the closure by transferring ownership of value to the sort_operations vector. This closure can be called once; trying to call it a second time wouldn’t work because value would no longer be in the environment to be pushed into sort_operations again! Therefore, this closure only implements FnOnce. When we try to compile this code, we get this error that value can’t be moved out of the closure because the closure must implement FnMut:">这是一个复杂且不正确的方法，试图计算在对 <code>list</code> 进行排序时 <code>sort_by_key</code> 调用闭包的次数。这段代码试图通过将 <code>value</code>——一个来自闭包环境的 <code>String</code>——推入 <code>sort_operations</code> 向量来实现计数。闭包捕获 <code>value</code>，然后通过将 <code>value</code> 的所有权转移给 <code>sort_operations</code> 向量，将 <code>value</code> 移出闭包。这个闭包只能被调用一次；尝试第二次调用时将无法工作，因为 <code>value</code> 已经不在环境中，无法再次推入 <code>sort_operations</code>！因此，这个闭包只实现了 <code>FnOnce</code>。当我们尝试编译这段代码时，会得到一个错误，指出 <code>value</code> 不能从闭包中移出，因为闭包必须实现 <code>FnMut</code>：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p data-x-en="The error points to the line in the closure body that moves value out of the environment. To fix this, we need to change the closure body so that it doesn’t move values out of the environment. Keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to count the number of times the closure is called. The closure in Listing 13-9 works with sort_by_key because it is only capturing a mutable reference to the num_sort_operations counter and can therefore be called more than once:">错误指向了闭包体中将 <code>value</code> 移出环境的行。要修复这个问题，我们需要更改闭包体，使其不将值移出环境。在环境中保留一个计数器，并在闭包体中增加其值，是一种更直接的方式来计算闭包被调用的次数。列表 13-9 中的闭包可以与 <code>sort_by_key</code> 一起工作，因为它只捕获了 <code>num_sort_operations</code> 计数器的可变引用，因此可以被调用多次：</p>
<figure class="listing" id="listing-13-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
<figcaption><a href="#listing-13-9">Listing 13-9</a>: Using an <code>FnMut</code> closure with <code>sort_by_key</code> is allowed</figcaption>
</figure>
<p data-x-en="The Fn traits are important when defining or using functions or types that make use of closures. In the next section, we’ll discuss iterators. Many iterator methods take closure arguments, so keep these closure details in mind as we continue!"><code>Fn</code> 特性在定义或使用函数或类型时非常重要，这些函数或类型会使用闭包。在下一节中，我们将讨论迭代器。许多迭代器方法接受闭包参数，因此在我们继续时，请记住这些闭包细节。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>