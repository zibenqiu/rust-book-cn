<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>处理任意数量的 Future - 《Rust 编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch17-03-more-futures.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="working-with-any-number-of-futures"><a class="header" href="#working-with-any-number-of-futures">处理任意数量的 Future</a></h2>
<p data-x-en="When we switched from using two futures to three in the previous section, we also had to switch from using join to using join3. It would be annoying to have to call a different function every time we changed the number of futures we wanted to join. Happily, we have a macro form of join to which we can pass an arbitrary number of arguments. It also handles awaiting the futures itself. Thus, we could rewrite the code from Listing 17-13 to use join! instead of join3, as in Listing 17-14.">当我们从使用两个 future 转变为使用三个 future 时，我们还必须从使用 <code>join</code> 转变为使用 <code>join3</code>。每次我们改变想要连接的 future 数量时，都必须调用不同的函数，这会很烦人。幸运的是，我们有一个 <code>join</code> 的宏形式，可以传递任意数量的参数。它还自行处理等待 future。因此，我们可以将列表 17-13 中的代码重写为使用 <code>join!</code> 而不是 <code>join3</code>，如列表 17-14 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-14: Using <code>join!</code> to wait for multiple futures</figcaption>
</figure>
<p data-x-en="This is definitely an improvement over swapping between join and join3 and join4 and so on! However, even this macro form only works when we know the number of futures ahead of time. In real-world Rust, though, pushing futures into a collection and then waiting on some or all the futures of them to complete is a common pattern.">这肯定比在 <code>join</code> 和 <code>join3</code> 和 <code>join4</code> 之间切换要好！然而，即使这种宏形式也只能在我们提前知道未来数量的情况下工作。然而，在实际的 Rust 中，将未来推入集合，然后等待其中一些或所有未来完成，是一种常见的模式。</p>
<p data-x-en="To check all the futures in some collection, we’ll need to iterate over and join on all of them. The trpl::join_all function accepts any type that implements the Iterator trait, which you learned about back in The Iterator Trait and the next Method Chapter 13, so it seems like just the ticket. Let’s try putting our futures in a vector and replacing join! with join_all as shown in Listing 17-15.">要检查集合中的所有 future，我们需要遍历并连接<em>所有</em>的它们。<code>trpl::join_all</code> 函数接受任何实现了 <code>Iterator</code> 特性的类型，这在 <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">第 13 章的“迭代器特性与 <code>next</code> 方法”</a> 中已经介绍过，因此它似乎正是我们需要的。让我们尝试将我们的 future 放入一个向量中，并用 <code>join_all</code> 替换 <code>join!</code>，如清单 17-15 所示。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-15: Storing anonymous futures in a vector and calling <code>join_all</code></figcaption>
</figure>
<p data-x-en="Unfortunately, this code doesn’t compile. Instead, we get this error:">不幸的是，这段代码无法编译。相反，我们得到了这个错误：</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p data-x-en="This might be surprising. After all, none of the async blocks returns anything, so each one produces a Future<Output = ()>. Remember that Future is a trait, though, and that the compiler creates a unique enum for each async block. You can’t put two different hand-written structs in a Vec, and the same rule applies to the different enums generated by the compiler.">这可能会让你感到惊讶。毕竟，所有的异步块都没有返回任何内容，
所以每个异步块都会生成一个<code>Future&lt;Output = ()&gt;</code>。不过，要记住<code>Future</code>是一个特质，
而且编译器为每个异步块创建了一个唯一的枚举。你不能将两个不同的手写结构体放入一个<code>Vec</code>中，
同样，这个规则也适用于编译器生成的不同枚举。</p>
<p data-x-en="To make this work, we need to use trait objects, just as we did in “Returning Errors from the run function” in Chapter 12. (We’ll cover trait objects in detail in Chapter 18.) Using trait objects lets us treat each of the anonymous futures produced by these types as the same type, because all of them implement the Future trait.">要使这工作，我们需要使用<em>trait 对象</em>，就像我们在<a href="ch12-03-improving-error-handling-and-modularity.html">“从 run 函数返回错误”</a>第 12 章中所做的那样。（我们将在第 18 章详细讨论 trait 对象。）使用 trait 对象让我们可以将这些类型产生的每个匿名 future 视为同一类型，因为它们都实现了<code>Future</code> trait。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: In Using an Enum to Store Multiple Values in Chapter 8, we discussed another way to include multiple types in a Vec: using an enum to represent each type that can appear in the vector. We can’t do that here, though. For one thing, we have no way to name the different types, because they are anonymous. For another, the reason we reached for a vector and join_all in the first place was to be able to work with a dynamic collection of futures where we only care that they have the same output type.">注意：在 <a href="ch08-01-vectors.html#using-an-enum-to-store-multiple-types">使用枚举存储多个值</a><!-- ignore --> 中
第8章，我们讨论了另一种在<code>Vec</code>中包含多种类型的方法：使用枚举来表示可以在向量中出现的每种类型。然而，我们在这里不能这样做。一方面，我们无法命名不同的类型，因为它们是匿名的。另一方面，我们首先选择向量和<code>join_all</code>的原因是为了能够处理一个动态的未来集合，而我们只关心它们具有相同的输出类型。</p>
</section>
<p data-x-en="We start by wrapping each future in the vec! in a Box::new, as shown in Listing 17-16.">我们首先将每个未来值用 <code>Box::new</code> 包装在 <code>vec!</code> 中，如清单 17-16 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-16: Using <code>Box::new</code> to align the types of the futures in a <code>Vec</code></figcaption>
</figure>
<p data-x-en="Unfortunately, this code still doesn’t compile. In fact, we get the same basic error we got before for both the second and third Box::new calls, as well as new errors referring to the Unpin trait. We’ll come back to the Unpin errors in a moment. First, let’s fix the type errors on the Box::new calls by explicitly annotating the type of the futures variable (see Listing 17-17).">不幸的是，这段代码仍然无法编译。事实上，我们为第二个和第三个 <code>Box::new</code> 调用得到了与之前相同的错误，以及一些新的错误，这些错误涉及 <code>Unpin</code> 特性。我们稍后会回到 <code>Unpin</code> 错误。首先，让我们通过显式注解 <code>futures</code> 变量的类型来修复 <code>Box::new</code> 调用的类型错误（参见清单 17-17）。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-17: Fixing the rest of the type mismatch errors by using an explicit type declaration</figcaption>
</figure>
<p data-x-en="This type declaration is a little involved, so let’s walk through it:">这种类型声明有点复杂，所以我们来逐步分析一下：</p>
<ol>
<li data-x-en="The innermost type is the future itself. We note explicitly that the output of the future is the unit type () by writing Future<Output = ()>.">最内层的类型是未来本身。我们明确指出，未来的输出是单元类型<code>()</code>，通过写<code>Future&lt;Output = ()&gt;</code>。</li>
<li data-x-en="Then we annotate the trait with dyn to mark it as dynamic.">然后我们用 <code>dyn</code> 注解这个 trait 以标记它为动态。</li>
<li data-x-en="The entire trait reference is wrapped in a Box.">整个特征引用被包裹在一个 <code>Box</code> 中。</li>
<li data-x-en="Finally, we state explicitly that futures is a Vec containing these items.">最后，我们明确指出 <code>futures</code> 是一个包含这些项的 <code>Vec</code>。</li>
</ol>
<p data-x-en="That already made a big difference. Now when we run the compiler, we get only the errors mentioning Unpin. Although there are three of them, their contents are very similar.">这已经产生了很大的不同。现在当我们运行编译器时，我们只会得到提到<code>Unpin</code>的错误。虽然有三个错误，但它们的内容非常相似。</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-17
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
   --&gt; src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `async_await` (bin "async_await") due to 3 previous errors
</code></pre>
<p data-x-en="That is a lot to digest, so let’s pull it apart. The first part of the message tell us that the first async block (src/main.rs:8:23: 20:10) does not implement the Unpin trait and suggests using pin! or Box::pin to resolve it. Later in the chapter, we’ll dig into a few more details about Pin and Unpin. For the moment, though, we can just follow the compiler’s advice to get unstuck. In Listing 17-18, we start by importing Pin from std::pin. Next we update the type annotation for futures, with a Pin wrapping each Box. Finally, we use Box::pin to pin the futures themselves.">这有<em>很多</em>需要消化的内容，所以我们来拆解一下。消息的第一部分
告诉我们第一个异步块（<code>src/main.rs:8:23: 20:10</code>）没有
实现<code>Unpin</code>特质，并建议使用<code>pin!</code>或<code>Box::pin</code>来解决
它。在本章的后面，我们将深入探讨更多关于<code>Pin</code>和
<code>Unpin</code>的细节。不过，目前我们只需按照编译器的建议来解决问题。在清单17-18中，我们首先从<code>std::pin</code>导入<code>Pin</code>。接下来我们
更新<code>futures</code>的类型注解，每个<code>Box</code>都用<code>Pin</code>包裹。
最后，我们使用<code>Box::pin</code>来固定这些未来对象。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::Pin;

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-18: Using <code>Pin</code> and <code>Box::pin</code> to make the <code>Vec</code> type check</figcaption>
</figure>
<p data-x-en="If we compile and run this, we finally get the output we hoped for:">如果我们编译并运行这个程序，我们最终会得到我们希望的输出：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p data-x-en="Phew!"><p>呼！</p></p>
<p data-x-en="There’s a bit more to explore here. For one thing, using Pin<Box<T>> adds a small amount of overhead from putting these futures on the heap with Box—and we’re only doing that to get the types to line up. We don’t actually need the heap allocation, after all: these futures are local to this particular function. As noted before, Pin is itself a wrapper type, so we can get the benefit of having a single type in the Vec—the original reason we reached for Box—without doing a heap allocation. We can use Pin directly with each future, using the std::pin::pin macro.">这里还有更多可以探索的内容。一方面，使用<code>Pin&lt;Box&lt;T&gt;&gt;</code> 会因为使用 <code>Box</code> 将这些 future 放在堆上而增加少量的开销——而我们这样做只是为了使类型对齐。毕竟，我们实际上并不需要堆分配：这些 future 仅限于这个特定的函数。如前所述，<code>Pin</code> 本身是一个包装类型，因此我们可以在 <code>Vec</code> 中获得单一类型的好处——这原本是我们使用 <code>Box</code> 的原因——而无需进行堆分配。我们可以直接使用 <code>Pin</code> 和每个 future，使用 <code>std::pin::pin</code> 宏。</p>
<p data-x-en="However, we must still be explicit about the type of the pinned reference; otherwise, Rust will still not know to interpret these as dynamic trait objects, which is what we need them to be in the Vec. We therefore add pin to our list of imports from std::pin. Then we can pin! each future when we define it and define futures as a Vec containing pinned mutable references to the dynamic future type, as in Listing 17-19.">然而，我们必须明确指出固定引用的类型；否则，Rust 仍然不知道将这些解释为动态特征对象，而这正是我们希望它们在 <code>Vec</code> 中成为的。因此，我们将 <code>pin</code> 添加到从 <code>std::pin</code> 导入的列表中。然后我们可以在定义每个未来时 <code>pin!</code> 它们，并将 <code>futures</code> 定义为包含指向动态未来类型的固定可变引用的 <code>Vec</code>，如清单 17-19 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::{Pin, pin};

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-19: Using <code>Pin</code> directly with the <code>pin!</code> macro to avoid unnecessary heap allocations</figcaption>
</figure>
<p data-x-en="We got this far by ignoring the fact that we might have different Output types. For example, in Listing 17-20, the anonymous future for a implements Future<Output = u32>, the anonymous future for b implements Future<Output = &amp;str>, and the anonymous future for c implements Future<Output = bool>.">我们通过忽略我们可能有不同的<code>Output</code>类型这一事实才走到这一步。例如，在示例 17-20 中，<code>a</code>的匿名未来实现了<code>Future&lt;Output = u32&gt;</code>，<code>b</code>的匿名未来实现了<code>Future&lt;Output = &amp;str&gt;</code>，<code>c</code>的匿名未来实现了<code>Future&lt;Output = bool&gt;</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-20: Three futures with distinct types</figcaption>
</figure>
<p data-x-en="We can use trpl::join! to await them, because it allows us to pass in multiple future types and produces a tuple of those types. We cannot use trpl::join_all, because it requires all of the futures passed in to have the same type. Remember, that error is what got us started on this adventure with Pin!">我们可以使用<code>trpl::join!</code>来等待它们，因为它允许我们传入多个未来类型并生成这些类型的元组。我们<em>不能</em>使用<code>trpl::join_all</code>，因为它要求传入的所有未来必须具有相同的类型。记住，那个错误是我们开始这次与<code>Pin</code>的冒险的原因！</p>
<p data-x-en="This is a fundamental tradeoff: we can either deal with a dynamic number of futures with join_all, as long as they all have the same type, or we can deal with a set number of futures with the join functions or the join! macro, even if they have different types. This is the same scenario we’d face when working with any other types in Rust. Futures are not special, even though we have some nice syntax for working with them, and that’s a good thing.">这是一个基本的权衡：我们可以使用<code>join_all</code>处理动态数量的未来对象，只要它们都具有相同的类型，或者我们可以使用<code>join</code>函数或<code>join!</code>宏处理固定数量的未来对象，即使它们具有不同的类型。这与我们在Rust中处理任何其他类型时面临的情况相同。未来对象并不特殊，尽管我们有一些不错的语法来处理它们，这是一件好事。</p>
<h3 id="racing-futures"><a class="header" href="#racing-futures">竞赛的未来</a></h3>
<p data-x-en="When we “join” futures with the join family of functions and macros, we require all of them to finish before we move on. Sometimes, though, we only need some future from a set to finish before we move on—kind of similar to racing one future against another.">当我们使用 <code>join</code> 系列函数和宏“连接”未来值时，我们要求 <em>所有</em> 未来值都完成之后才继续前进。然而，有时我们只需要 <em>某些</em> 未来值从一组中完成之后就可以继续前进——有点类似于让一个未来值与另一个未来值竞赛。</p>
<p data-x-en="In Listing 17-21, we once again use trpl::race to run two futures, slow and fast, against each other.">在清单 17-21 中，我们再次使用 <code>trpl::race</code> 来运行两个未来值，<code>slow</code> 和 <code>fast</code>，相互竞争。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-21: Using <code>race</code> to get the result of whichever future finishes first</figcaption>
</figure>
<p data-x-en="Each future prints a message when it starts running, pauses for some amount of time by calling and awaiting sleep, and then prints another message when it finishes. Then we pass both slow and fast to trpl::race and wait for one of them to finish. (The outcome here isn’t too surprising: fast wins.) Unlike when we used race back in “Our First Async Program”, we just ignore the Either instance it returns here, because all of the interesting behavior happens in the body of the async blocks.">每个 future 在开始运行时会打印一条消息，通过调用并等待 <code>sleep</code> 暂停一段时间，然后在完成时打印另一条消息。然后我们将 <code>slow</code> 和 <code>fast</code> 传递给 <code>trpl::race</code> 并等待其中一个完成。（这里的结局并不太令人意外：<code>fast</code> 赢了。）与我们在 <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“我们的第一个异步程序”</a><!--
ignore --> 中使用 <code>race</code> 时不同，这里我们只是忽略它返回的 <code>Either</code> 实例，因为所有有趣的行为都发生在异步块的主体中。</p>
<p data-x-en="Notice that if you flip the order of the arguments to race, the order of the “started” messages changes, even though the fast future always completes first. That’s because the implementation of this particular race function is not fair. It always runs the futures passed in as arguments in the order in which they’re passed. Other implementations are fair and will randomly choose which future to poll first. Regardless of whether the implementation of race we’re using is fair, though, one of the futures will run up to the first await in its body before another task can start.">请注意，如果你调换 <code>race</code> 函数参数的顺序，“started” 消息的顺序也会改变，即使 <code>fast</code> 未来总是首先完成。这是因为这个特定的 <code>race</code> 函数的实现是不公平的。它总是按照参数传递的顺序运行传递的未来。其他实现 <em>是</em> 公平的，会随机选择首先轮询哪个未来。然而，无论我们使用的 <code>race</code> 函数实现是否公平，<em>一个</em> 未来将在另一个任务开始之前运行到其主体中的第一个 <code>await</code>。</p>
<p data-x-en="Recall from Our First Async Program that at each await point, Rust gives a runtime a chance to pause the task and switch to another one if the future being awaited isn’t ready. The inverse is also true: Rust only pauses async blocks and hands control back to a runtime at an await point. Everything between await points is synchronous.">回想 <a href="ch17-01-futures-and-syntax.html#our-first-async-program">我们的第一个异步程序</a> 中，在每个 await 点，Rust 会给运行时一个机会，如果正在等待的未来值尚未准备好，可以暂停任务并切换到另一个任务。相反的情况也成立：Rust <em>仅</em> 在 await 点暂停异步块并将控制权交还给运行时。await 点之间的所有内容都是同步的。</p>
<p data-x-en="That means if you do a bunch of work in an async block without an await point, that future will block any other futures from making progress. You may sometimes hear this referred to as one future starving other futures. In some cases, that may not be a big deal. However, if you are doing some kind of expensive setup or long-running work, or if you have a future that will keep doing some particular task indefinitely, you’ll need to think about when and where to hand control back to the runtime.">这意味着，如果你在一个异步块中进行大量工作而没有 await 点，
这个未来对象将会阻塞其他未来对象的进展。有时你可能会听到这种情况被称为一个未来对象 <em>饿死</em> 其他未来对象。在某些情况下，
这可能不是什么大问题。然而，如果你正在进行某种昂贵的设置或长时间运行的工作，或者如果你有一个未来对象将无限期地持续执行某项特定任务，你就需要考虑何时何地将控制权交还给运行时。</p>
<p data-x-en="By the same token, if you have long-running blocking operations, async can be a useful tool for providing ways for different parts of the program to relate to each other.">同样地，如果你有长时间运行的阻塞操作，异步可以是一个有用的工具，为程序的不同部分提供相互关联的方式。</p>
<p data-x-en="But how would you hand control back to the runtime in those cases?">但是在这些情况下，你<em>如何</em>将控制权交还给运行时？</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="yielding-control-to-the-runtime"><a class="header" href="#yielding-control-to-the-runtime">将控制权交给运行时</a></h3>
<p data-x-en="Let’s simulate a long-running operation. Listing 17-22 introduces a slow function.">让我们模拟一个长时间运行的操作。清单 17-22 引入了一个 <code>slow</code> 函数。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
<figcaption>Listing 17-22: Using <code>thread::sleep</code> to simulate slow operations</figcaption>
</figure>
<p data-x-en="This code uses std::thread::sleep instead of trpl::sleep so that calling slow will block the current thread for some number of milliseconds. We can use slow to stand in for real-world operations that are both long-running and blocking.">这段代码使用 <code>std::thread::sleep</code> 而不是 <code>trpl::sleep</code>，因此调用 <code>slow</code> 将会阻塞当前线程一段时间（毫秒）。我们可以使用 <code>slow</code> 来模拟现实世界中既耗时又阻塞的操作。</p>
<p data-x-en="In Listing 17-23, we use slow to emulate doing this kind of CPU-bound work in a pair of futures.">在清单 17-23 中，我们使用 <code>slow</code> 来模拟在一对 future 中执行这种 CPU 密集型工作。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-23: Using <code>thread::sleep</code> to simulate slow operations</figcaption>
</figure>
<p data-x-en="To begin, each future only hands control back to the runtime after carrying out a bunch of slow operations. If you run this code, you will see this output:">首先，每个 future 只有在执行了一组缓慢操作 <em>之后</em> 才将控制权交还给运行时。如果你运行这段代码，你会看到如下输出：</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p data-x-en="As with our earlier example, race still finishes as soon as a is done. There’s no interleaving between the two futures, though. The a future does all of its work until the trpl::sleep call is awaited, then the b future does all of its work until its own trpl::sleep call is awaited, and finally the a future completes. To allow both futures to make progress between their slow tasks, we need await points so we can hand control back to the runtime. That means we need something we can await!">与我们之前的例子一样，<code>race</code> 仍然在 <code>a</code> 完成时结束。
不过，这两个未来之间没有交错。 <code>a</code> 未来在其 <code>trpl::sleep</code> 调用被等待之前完成了所有的工作，然后 <code>b</code> 未来在其自己的 <code>trpl::sleep</code> 调用被等待之前完成了所有的工作，最后 <code>a</code> 未来完成。为了在它们的慢任务之间让两个未来都能取得进展，我们需要等待点，以便我们可以将控制权交还给运行时。这意味着我们需要一些可以等待的东西！</p>
<p data-x-en="We can already see this kind of handoff happening in Listing 17-23: if we removed the trpl::sleep at the end of the a future, it would complete without the b future running at all. Let’s try using the sleep function as a starting point for letting operations switch off making progress, as shown in Listing 17-24.">我们已经在清单 17-23 中看到了这种交接的发生：如果我们移除 <code>a</code> 未来末尾的 <code>trpl::sleep</code>，它将在 <code>b</code> 未来完全不运行的情况下完成。让我们尝试使用 <code>sleep</code> 函数作为让操作交替进行的起点，如清单 17-24 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-24: Using <code>sleep</code> to let operations switch off making progress</figcaption>
</figure>
<p data-x-en="In Listing 17-24, we add trpl::sleep calls with await points between each call to slow. Now the two futures’ work is interleaved:">在清单 17-24 中，我们在每次调用 <code>slow</code> 之间添加了带有 await 点的 <code>trpl::sleep</code> 调用。现在两个未来的任务是交错进行的：</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p data-x-en="The a future still runs for a bit before handing off control to b, because it calls slow before ever calling trpl::sleep, but after that the futures swap back and forth each time one of them hits an await point. In this case, we have done that after every call to slow, but we could break up the work in whatever way makes the most sense to us."><code>a</code> 未来在将控制权交给 <code>b</code> 之前仍然运行一段时间，因为它在调用 <code>trpl::sleep</code> 之前先调用了 <code>slow</code>，但在那之后，每当其中一个到达 await 点时，这些未来就会来回交换。在这种情况下，我们在每次调用 <code>slow</code> 之后都这样做了，但我们可以根据需要以任何最合理的方式分配工作。</p>
<p data-x-en="We don’t really want to sleep here, though: we want to make progress as fast as we can. We just need to hand back control to the runtime. We can do that directly, using the yield_now function. In Listing 17-25, we replace all those sleep calls with yield_now.">我们并不真的想在这里<em>睡眠</em>：我们希望尽可能快地取得进展。我们只需要将控制权交还给运行时。我们可以直接使用<code>yield_now</code>函数来实现。在清单17-25中，我们将所有那些<code>sleep</code>调用替换为<code>yield_now</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-25: Using <code>yield_now</code> to let operations switch off making progress</figcaption>
</figure>
<p data-x-en="This code is both clearer about the actual intent and can be significantly faster than using sleep, because timers such as the one used by sleep often have limits on how granular they can be. The version of sleep we are using, for example, will always sleep for at least a millisecond, even if we pass it a Duration of one nanosecond. Again, modern computers are fast: they can do a lot in one millisecond!">这段代码不仅更清楚地表达了实际意图，而且由于像 <code>sleep</code> 这样的定时器通常有粒度限制，因此可以显著快于使用 <code>sleep</code>。例如，我们使用的 <code>sleep</code> 版本，即使我们传递一个 <code>Duration</code> 为一纳秒，也会至少休眠一毫秒。再次强调，现代计算机 <em>非常快</em>：它们在一毫秒内可以完成很多事情！</p>
<p data-x-en="You can see this for yourself by setting up a little benchmark, such as the one in Listing 17-26. (This isn’t an especially rigorous way to do performance testing, but it suffices to show the difference here.)">你可以通过设置一个小基准测试自己看看，例如列表 17-26 中的示例。（这并不是一种特别严谨的性能测试方法，但足以显示这里的差异。）</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-26: Comparing the performance of <code>sleep</code> and <code>yield_now</code></figcaption>
</figure>
<p data-x-en="Here, we skip all the status printing, pass a one-nanosecond Duration to trpl::sleep, and let each future run by itself, with no switching between the futures. Then we run for 1,000 iterations and see how long the future using trpl::sleep takes compared to the future using trpl::yield_now.">这里，我们跳过所有状态打印，将一个纳秒的<code>Duration</code>传递给<code>trpl::sleep</code>，并让每个未来自行运行，不在这几个未来之间切换。然后我们运行1,000次迭代，看看使用<code>trpl::sleep</code>的未来与使用<code>trpl::yield_now</code>的未来相比需要多长时间。</p>
<p data-x-en="The version with yield_now is way faster!">带有 <code>yield_now</code> 的版本 <em>快得多</em>！</p>
<p data-x-en="This means that async can be useful even for compute-bound tasks, depending on what else your program is doing, because it provides a useful tool for structuring the relationships between different parts of the program. This is a form of cooperative multitasking, where each future has the power to determine when it hands over control via await points. Each future therefore also has the responsibility to avoid blocking for too long. In some Rust-based embedded operating systems, this is the only kind of multitasking!">这意味着，即使对于计算密集型任务，async 也可以非常有用，这取决于程序的其他部分在做什么，因为它提供了一种有用的工具来结构化程序不同部分之间的关系。这是一种 <em>协作式多任务处理</em>，每个 future 都有权决定何时通过 await 点交出控制权。因此，每个 future 也有责任避免阻塞时间过长。在某些基于 Rust 的嵌入式操作系统中，这是 <em>唯一</em> 的多任务处理方式！</p>
<p data-x-en="In real-world code, you won’t usually be alternating function calls with await points on every single line, of course. While yielding control in this way is relatively inexpensive, it’s not free. In many cases, trying to break up a compute-bound task might make it significantly slower, so sometimes it’s better for overall performance to let an operation block briefly. Always measure to see what your code’s actual performance bottlenecks are. The underlying dynamic is important to keep in mind, though, if you are seeing a lot of work happening in serial that you expected to happen concurrently!">在实际代码中，你通常不会在每一行代码中交替使用函数调用和 await
点，当然。虽然以这种方式让出控制权相对便宜，但并非免费。在许多情况下，尝试将计算密集型任务分解可能会使其显著变慢，因此有时为了 <em>整体</em> 性能，让一个操作短暂阻塞会更好。始终测量以了解代码的实际性能瓶颈是什么。然而，如果你 <em>确实</em> 看到很多你期望并发执行的工作实际上是串行执行的，那么底层的动态机制就很重要了！</p>
<h3 id="building-our-own-async-abstractions"><a class="header" href="#building-our-own-async-abstractions">构建我们自己的异步抽象</a></h3>
<p data-x-en="We can also compose futures together to create new patterns. For example, we can build a timeout function with async building blocks we already have. When we’re done, the result will be another building block we could use to create still more async abstractions.">我们还可以将多个 future 组合在一起以创建新的模式。例如，我们可以
使用我们已经拥有的异步构建块来构建一个 <code>timeout</code> 函数。完成后，
结果将是一个新的构建块，我们可以用它来创建更多的异步抽象。</p>
<p data-x-en="Listing 17-27 shows how we would expect this timeout to work with a slow future.">列表 17-27 显示了我们期望这个 <code>timeout</code> 如何与一个慢的未来一起工作。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-27: Using our imagined <code>timeout</code> to run a slow operation with a time limit</figcaption>
</figure>
<p data-x-en="Let’s implement this! To begin, let’s think about the API for timeout:">让我们来实现这个！首先，让我们思考一下 <code>timeout</code> 的 API：</p>
<ul>
<li data-x-en="It needs to be an async function itself so we can await it.">它本身需要是一个异步函数，这样我们才能等待它。</li>
<li data-x-en="Its first parameter should be a future to run. We can make it generic to allow it to work with any future.">它的第一个参数应该是要运行的 future。我们可以将其泛化以允许与任何 future 一起使用。</li>
<li data-x-en="Its second parameter will be the maximum time to wait. If we use a Duration, that will make it easy to pass along to trpl::sleep.">其第二个参数将是最大等待时间。如果我们使用 <code>Duration</code>，这将使其易于传递给 <code>trpl::sleep</code>。</li>
<li data-x-en="It should return a Result. If the future completes successfully, the Result will be Ok with the value produced by the future. If the timeout elapses first, the Result will be Err with the duration that the timeout waited for.">它应该返回一个 <code>Result</code>。如果未来完成成功，<code>Result</code> 将是 <code>Ok</code>，包含未来产生的值。如果超时先发生，<code>Result</code> 将是 <code>Err</code>，包含超时等待的持续时间。</li>
</ul>
<p data-x-en="Listing 17-28 shows this declaration.">列表 17-28 显示了此声明。</p>
<!-- This is not tested because it intentionally does not compile. -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
<figcaption>Listing 17-28: Defining the signature of <code>timeout</code></figcaption>
</figure>
<p data-x-en="That satisfies our goals for the types. Now let’s think about the behavior we need: we want to race the future passed in against the duration. We can use trpl::sleep to make a timer future from the duration, and use trpl::race to run that timer with the future the caller passes in.">这满足了我们对类型的要求。现在让我们考虑需要的<em>行为</em>：我们希望将传入的未来与持续时间进行竞赛。我们可以使用<code>trpl::sleep</code>从持续时间创建一个计时器未来，并使用<code>trpl::race</code>来运行计时器与调用者传入的未来。</p>
<p data-x-en="We also know that race is not fair, polling arguments in the order in which they are passed. Thus, we pass future_to_try to race first so it gets a chance to complete even if max_time is a very short duration. If future_to_try finishes first, race will return Left with the output from future_to_try. If timer finishes first, race will return Right with the timer’s output of ().">我们还知道 <code>race</code> 是不公平的，它按照传递的顺序轮询参数。因此，我们首先将 <code>future_to_try</code> 传递给 <code>race</code>，以便即使 <code>max_time</code> 是一个非常短的时间段，它也有机会完成。如果 <code>future_to_try</code> 首先完成，<code>race</code> 将返回 <code>Left</code>，其中包含 <code>future_to_try</code> 的输出。如果 <code>timer</code> 首先完成，<code>race</code> 将返回 <code>Right</code>，其中包含定时器的输出 <code>()</code>。</p>
<p data-x-en="In Listing 17-29, we match on the result of awaiting trpl::race.">在清单 17-29 中，我们对 <code>trpl::race</code> 的结果进行匹配。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-29: Defining <code>timeout</code> with <code>race</code> and <code>sleep</code></figcaption>
</figure>
<p data-x-en="If the future_to_try succeeds and we get a Left(output), we return Ok(output). If the sleep timer elapses instead and we get a Right(()), we ignore the () with _ and return Err(max_time) instead.">如果 <code>future_to_try</code> 成功并且我们得到一个 <code>Left(output)</code>，我们返回 <code>Ok(output)</code>。如果睡眠计时器到期并且我们得到一个 <code>Right(())</code>，我们用 <code>_</code> 忽略 <code>()</code> 并返回 <code>Err(max_time)</code>。</p>
<p data-x-en="With that, we have a working timeout built out of two other async helpers. If we run our code, it will print the failure mode after the timeout:">至此，我们已经使用两个其他异步助手构建了一个工作的<code>timeout</code>。如果我们运行我们的代码，它将在超时后打印失败模式：</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p data-x-en="Because futures compose with other futures, you can build really powerful tools using smaller async building blocks. For example, you can use this same approach to combine timeouts with retries, and in turn use those with operations such as network calls (one of the examples from the beginning of the chapter).">因为 Future 可以与其他 Future 组合，所以你可以使用较小的异步构建块来构建非常强大的工具。例如，你可以使用相同的方法将超时与重试结合起来，然后将这些与网络调用等操作（本章开头的一个例子）一起使用。</p>
<p data-x-en="In practice, you’ll usually work directly with async and await, and secondarily with functions and macros such as join, join_all, race, and so on. You’ll only need to reach for pin now and again to use futures with those APIs.">在实际中，你通常会直接使用 <code>async</code> 和 <code>await</code>，其次会使用诸如 <code>join</code>、<code>join_all</code>、<code>race</code> 等函数和宏。你只需要偶尔使用 <code>pin</code> 来与这些 API 一起使用 futures。</p>
<p data-x-en="We’ve now seen a number of ways to work with multiple futures at the same time. Up next, we’ll look at how we can work with multiple futures in a sequence over time with streams. Here are a couple more things you might want to consider first, though:">我们现在看到了同时处理多个未来的几种方法。接下来，我们将看看如何使用<em>流</em>在一段时间内按顺序处理多个未来。不过，在此之前，你可能还想考虑以下几点：</p>
<ul>
<li data-x-en="We used a Vec with join_all to wait for all of the futures in some group to finish. How could you use a Vec to process a group of futures in sequence instead? What are the tradeoffs of doing that?">我们使用了 <code>Vec</code> 和 <code>join_all</code> 来等待某组中所有未来的完成。你如何使用 <code>Vec</code> 来按顺序处理一组未来的？这样做有什么权衡？</li>
<li data-x-en="Take a look at the futures::stream::FuturesUnordered type from the futures crate. How would using it be different from using a Vec? (Don’t worry about the fact that it’s from the stream part of the crate; it works just fine with any collection of futures.)">查看 <code>futures::stream::FuturesUnordered</code> 类型，来自 <code>futures</code>
库。使用它与使用 <code>Vec</code> 有什么不同？（不用担心它是从库的 <code>stream</code> 部分来的；它可以很好地与任何未来的集合一起使用。）</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>