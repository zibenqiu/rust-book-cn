{
  "Appendix A: Keywords": {
    "_translate": "<a class=\"header\" href=\"#appendix-a-keywords\">附录 A: 关键字</a>",
    "_note": ""
  },
  "Keywords Currently in Use": {
    "_translate": "<a class=\"header\" href=\"#keywords-currently-in-use\">当前使用的关键词</a>",
    "_note": ""
  },
  "The following is a list of keywords currently in use, with their functionality described.": {
    "_translate": "以下是在使用的关键词列表，以及它们的功能描述。",
    "_note": ""
  },
  "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we’ll discuss in the “Raw Identifiers” section). Identifiers are names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.": {
    "_translate": "以下列表包含 Rust 语言为当前或未来使用而保留的关键词。因此，它们不能用作标识符（除非作为原始标识符，我们将在“<a href=\"#raw-identifiers\">原始标识符</a><!-- ignore -->”部分讨论）。标识符是函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、特征或生命周期的名称。",
    "_note": ""
  },
  "Keywords Reserved for Future Use": {
    "_translate": "<a class=\"header\" href=\"#keywords-reserved-for-future-use\">为将来保留的关键词</a>",
    "_note": ""
  },
  "The following keywords do not yet have any functionality but are reserved by Rust for potential future use.": {
    "_translate": "以下关键字目前尚无任何功能，但 Rust 保留了这些关键字以供将来可能使用。",
    "_note": ""
  },
  "Raw Identifiers": {
    "_translate": "<a class=\"header\" href=\"#raw-identifiers\">原始标识符</a>",
    "_note": ""
  },
  "For example, match is a keyword. If you try to compile the following function that uses match as its name:": {
    "_translate": "例如，<code>match</code> 是一个关键字。如果你尝试编译以下使用 <code>match</code> 作为其名称的函数：",
    "_note": ""
  },
  "Raw identifiers are the syntax that lets you use keywords where they wouldn’t normally be allowed. You use a raw identifier by prefixing a keyword with r#.": {
    "_translate": "<em>原始标识符</em> 是允许你在通常不允许使用关键字的地方使用关键字的语法。你通过在关键字前加上 <code>r#</code> 来使用原始标识符。",
    "_note": ""
  },
  "you’ll get this error:": {
    "_translate": "你会遇到这个错误：",
    "_note": ""
  },
  "Filename: src/main.rs": {
    "_translate": "<span class=\"filename\">文件名: src/main.rs</span>",
    "_note": ""
  },
  "The error shows that you can’t use the keyword match as the function identifier. To use match as a function name, you need to use the raw identifier syntax, like this:": {
    "_translate": "错误显示你不能将关键字<code>match</code>用作函数标识符。要将<code>match</code>用作函数名，你需要使用原始标识符语法，如下所示：",
    "_note": ""
  },
  "This code will compile without any errors. Note the r# prefix on the function name in its definition as well as where the function is called in main.": {
    "_translate": "这段代码将不会出现任何编译错误。注意函数定义及其在 <code>main</code> 中被调用时的函数名前的 <code>r#</code> 前缀。",
    "_note": ""
  },
  "Raw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. This gives us more freedom to choose identifier names, as well as lets us integrate with programs written in a language where these words aren’t keywords. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, try isn’t a keyword in the 2015 edition but is in the 2018 edition. If you depend on a library that’s written using the 2015 edition and has a try function, you’ll need to use the raw identifier syntax, r#try in this case, to call that function from your 2018 edition code. See Appendix E for more information on editions.": {
    "_translate": "原始标识符允许你使用任何你选择的标识符，即使该词碰巧是保留关键字。这给了我们更多的自由来选择标识符名称，同时也让我们能够与那些这些词不是关键字的语言编写的程序集成。此外，原始标识符允许你使用与你的 crate 使用的不同 Rust 版本编写的库。例如，<code>try</code> 在 2015 版本中不是关键字，但在 2018 版本中是。如果你依赖于一个使用 2015 版本编写的库，并且该库有一个 <code>try</code> 函数，你需要使用原始标识符语法，<code>r#try</code> 在这种情况下，从你的 2018 版本代码中调用该函数。有关版本的更多信息，请参见 <a href=\"appendix-05-editions.html\">附录 E</a><!-- ignore -->。",
    "_note": ""
  },
  "A - Keywords - The Rust Programming Language": {
    "_translate": "A - 关键字 - 《Rust 编程语言》",
    "_note": ""
  },
  "as - perform primitive casting, disambiguate the specific trait containing an item, or rename items in use statements": {
    "_translate": "<code>as</code> - 执行原始类型转换，区分包含某个项的具体特征，或在 <code>use</code> 语句中重命名项",
    "_note": ""
  },
  "async - return a Future instead of blocking the current thread": {
    "_translate": "<code>async</code> - 返回一个 <code>Future</code> 而不是阻塞当前线程",
    "_note": ""
  },
  "await - suspend execution until the result of a Future is ready": {
    "_translate": "<code>await</code> - 暂停执行，直到 <code>Future</code> 的结果准备就绪",
    "_note": ""
  },
  "break - exit a loop immediately": {
    "_translate": "<code>break</code> - 立即退出循环",
    "_note": ""
  },
  "const - define constant items or constant raw pointers": {
    "_translate": "<code>const</code> - 定义常量项或常量原始指针",
    "_note": ""
  },
  "continue - continue to the next loop iteration": {
    "_translate": "<code>continue</code> - 继续下一次循环迭代",
    "_note": ""
  },
  "crate - in a module path, refers to the crate root": {
    "_translate": "<code>crate</code> - 在模块路径中，指的是 crate 根",
    "_note": ""
  },
  "dyn - dynamic dispatch to a trait object": {
    "_translate": "<code>dyn</code> - 动态分发到特征对象",
    "_note": ""
  },
  "enum - define an enumeration": {
    "_translate": "<code>enum</code> - 定义一个枚举",
    "_note": ""
  },
  "else - fallback for if and if let control flow constructs": {
    "_translate": "<code>else</code> - <code>if</code> 和 <code>if let</code> 控制流结构的回退选项",
    "_note": ""
  },
  "extern - link an external function or variable": {
    "_translate": "<code>extern</code> - 链接外部函数或变量",
    "_note": ""
  },
  "false - Boolean false literal": {
    "_translate": "<code>false</code> - 布尔假字面值",
    "_note": ""
  },
  "fn - define a function or the function pointer type": {
    "_translate": "<code>fn</code> - 定义一个函数或函数指针类型",
    "_note": ""
  },
  "if - branch based on the result of a conditional expression": {
    "_translate": "<code>if</code> - 根据条件表达式的结果进行分支",
    "_note": ""
  },
  "for - loop over items from an iterator, implement a trait, or specify a higher-ranked lifetime": {
    "_translate": "<code>for</code> - 遍历来自迭代器的项，实现一个特质，或指定一个高阶生命周期",
    "_note": ""
  },
  "impl - implement inherent or trait functionality": {
    "_translate": "<code>impl</code> - 实现固有或特征功能",
    "_note": ""
  },
  "in - part of for loop syntax": {
    "_translate": "<code>in</code> - <code>for</code> 循环语法的一部分",
    "_note": ""
  },
  "loop - loop unconditionally": {
    "_translate": "<code>loop</code> - 无条件循环",
    "_note": ""
  },
  "let - bind a variable": {
    "_translate": "<code>let</code> - 绑定一个变量",
    "_note": ""
  },
  "match - match a value to patterns": {
    "_translate": "<code>match</code> - 将值与模式匹配",
    "_note": ""
  },
  "mod - define a module": {
    "_translate": "<code>mod</code> - 定义一个模块",
    "_note": ""
  },
  "move - make a closure take ownership of all its captures": {
    "_translate": "<code>move</code> - 使闭包拥有其所有捕获的变量",
    "_note": ""
  },
  "mut - denote mutability in references, raw pointers, or pattern bindings": {
    "_translate": "<code>mut</code> - 在引用、原始指针或模式绑定中表示可变性",
    "_note": ""
  },
  "ref - bind by reference": {
    "_translate": "<code>ref</code> - 按引用绑定",
    "_note": ""
  },
  "pub - denote public visibility in struct fields, impl blocks, or modules": {
    "_translate": "<code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公共可见性",
    "_note": ""
  },
  "return - return from function": {
    "_translate": "<code>return</code> - 从函数返回",
    "_note": ""
  },
  "Self - a type alias for the type we are defining or implementing": {
    "_translate": "<code>Self</code> - 一个类型别名，用于我们正在定义或实现的类型。",
    "_note": ""
  },
  "static - global variable or lifetime lasting the entire program execution": {
    "_translate": "<code>static</code> - 全局变量或持续整个程序执行的生命周期",
    "_note": ""
  },
  "self - method subject or current module": {
    "_translate": "<code>self</code> - 方法主体或当前模块",
    "_note": ""
  },
  "struct - define a structure": {
    "_translate": "<code>struct</code> - 定义一个结构",
    "_note": ""
  },
  "super - parent module of the current module": {
    "_translate": "<code>super</code> - 当前模块的父模块",
    "_note": ""
  },
  "trait - define a trait": {
    "_translate": "<code>trait</code> - 定义一个特质",
    "_note": ""
  },
  "true - Boolean true literal": {
    "_translate": "<code>true</code> - 布尔真值字面量",
    "_note": ""
  },
  "type - define a type alias or associated type": {
    "_translate": "<code>type</code> - 定义类型别名或关联类型",
    "_note": ""
  },
  "union - define a union; is only a keyword when used in a union declaration": {
    "_translate": "<code>union</code> - 定义一个 <a href=\"../reference/items/unions.html\">联合体</a><!-- ignore -->; 仅在用于联合体声明时才是关键字",
    "_note": ""
  },
  "unsafe - denote unsafe code, functions, traits, or implementations": {
    "_translate": "<code>unsafe</code> - 表示不安全的代码、函数、特质或实现",
    "_note": ""
  },
  "use - bring symbols into scope": {
    "_translate": "<code>use</code> - 将符号引入作用域",
    "_note": ""
  },
  "where - denote clauses that constrain a type": {
    "_translate": "<code>where</code> - 表示限制类型的子句",
    "_note": ""
  },
  "while - loop conditionally based on the result of an expression": {
    "_translate": "<code>while</code> - 根据表达式的结果有条件地循环",
    "_note": ""
  },
  "abstract": {
    "_translate": "<code>抽象</code>",
    "_note": ""
  },
  "become": {
    "_translate": "<code>成为</code>",
    "_note": ""
  },
  "box": {
    "_translate": "<code>box</code>",
    "_note": ""
  },
  "do": {
    "_translate": "<code>执行</code>",
    "_note": ""
  },
  "final": {
    "_translate": "<code>最终</code>",
    "_note": ""
  },
  "macro": {
    "_translate": "<code>宏</code>",
    "_note": ""
  },
  "override": {
    "_translate": "<code>覆盖</code>",
    "_note": ""
  },
  "priv": {
    "_translate": "<code>私</code>",
    "_note": ""
  },
  "try": {
    "_translate": "<code>尝试</code>",
    "_note": ""
  },
  "typeof": {
    "_translate": "<code>typeof</code>",
    "_note": ""
  },
  "unsized": {
    "_translate": "<code>未定大小</code>",
    "_note": ""
  },
  "yield": {
    "_translate": "<code>yield</code>",
    "_note": ""
  },
  "virtual": {
    "_translate": "<code>虚拟</code>",
    "_note": ""
  },
  "gen": {
    "_translate": "<code>生成器</code>",
    "_note": ""
  },
  "Raw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. This gives us more freedom to choose identifier names, as well as lets us integrate with programs written in a language where these words aren’t keywords. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, try isn’t a keyword in the 2015 edition but is in the 2018, 2021, and 2024 editions. If you depend on a library that’s written using the 2015 edition and has a try function, you’ll need to use the raw identifier syntax, r#try in this case, to call that function from your 2018 edition code. See Appendix E for more information on editions.": {
    "_translate": "原始标识符允许你使用任何你选择的单词作为标识符，即使该单词碰巧是保留关键字。这给了我们更多的自由来选择标识符名称，同时也让我们能够与用其他语言编写的程序集成，这些语言中这些单词不是关键字。此外，原始标识符允许你使用与你的 crate 使用的不同 Rust 版本编写的库。例如，<code>try</code> 在 2015 版本中不是关键字，但在 2018、2021 和 2024 版本中是关键字。如果你依赖于使用 2015 版本编写的库，并且该库有一个 <code>try</code> 函数，你需要使用原始标识符语法，即 <code>r#try</code>，从你的 2018 版本代码中调用该函数。有关版本的更多信息，请参见 <a href=\"appendix-05-editions.html\">附录 E</a><!-- ignore -->。",
    "_note": ""
  },
  "use - bring symbols into scope; specify precise captures for generic and lifetime bounds": {
    "_translate": "<code>use</code> - 将符号引入作用域；为泛型和生命周期边界指定精确捕获；",
    "_note": ""
  },
  "Raw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. This gives us more freedom to choose identifier names, as well as lets us integrate with programs written in a language where these words aren’t keywords. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, try isn’t a keyword in the 2015 edition but is in the 2018, 2021, and 2024 editions. If you depend on a library that is written using the 2015 edition and has a try function, you’ll need to use the raw identifier syntax, r#try in this case, to call that function from your code on later editions. See Appendix E for more information on editions.": {
    "_translate": "原始标识符允许你使用任何你选择的单词作为标识符，即使该单词碰巧是保留关键字。这给了我们更多的自由来选择标识符名称，同时也让我们能够与这些单词不是关键字的其他语言编写的程序集成。此外，原始标识符允许你使用与你的 crate 使用的不同 Rust 版本编写的库。例如，<code>try</code> 在 2015 版本中不是关键字，但在 2018、2021 和 2024 版本中是关键字。如果你依赖于一个使用 2015 版本编写的库，并且该库有一个 <code>try</code> 函数，你需要使用原始标识符语法，即 <code>r#try</code>，在较新版本中调用该函数。有关版本的更多信息，请参见 <a href=\"appendix-05-editions.html\">附录 E</a><!-- ignore -->。",
    "_note": ""
  }
}