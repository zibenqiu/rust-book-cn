<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt; 和内部可变性模式 - 《Rust 编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch15-05-interior-mutability.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt-and-the-interior-mutability-pattern"><a class="header" href="#refcellt-and-the-interior-mutability-pattern"><code>RefCell&lt;T&gt;</code> 和内部可变性模式</a></h2>
<p data-x-en="Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we’re checking the rules manually instead of relying on the compiler to check them for us; we will discuss unsafe code more in Chapter 20."><em>内部可变性</em> 是 Rust 中的一种设计模式，它允许你在有不可变引用指向数据的情况下仍然可以修改数据；通常，这种操作是被借用规则禁止的。为了修改数据，该模式在数据结构内部使用 <code>unsafe</code> 代码来绕过 Rust 通常的关于修改和借用的规则。不安全代码向编译器表明我们正在手动检查规则，而不是依赖编译器为我们检查规则；我们将在第 20 章中更详细地讨论不安全代码。</p>
<p data-x-en="We can use types that use the interior mutability pattern only when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can’t guarantee that. The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.">我们只能在确保运行时将遵循借用规则的情况下使用使用内部可变性模式的类型，即使编译器无法保证这一点。<code>unsafe</code> 代码随后会被包装在一个安全的 API 中，而外部类型仍然是不可变的。</p>
<p data-x-en="Let’s explore this concept by looking at the RefCell<T> type that follows the interior mutability pattern.">让我们通过查看遵循内部可变性模式的 <code>RefCell&lt;T&gt;</code> 类型来探讨这个概念。</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcellt"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt">在运行时使用<code>RefCell&lt;T&gt;</code>强制借用规则</a></h3>
<p data-x-en="Unlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds. So, what makes RefCell<T> different from a type like Box<T>? Recall the borrowing rules you learned in Chapter 4:">Unlike <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 类型表示对其持有的数据具有单一所有权。那么，<code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 这样的类型有什么不同呢？回想你在第 4 章中学到的借用规则：</p>
<ul>
<li data-x-en="At any given time, you can have either (but not both) one mutable reference or any number of immutable references.">在任何时候，你可以有 <em>要么</em>（但不能同时拥有两者）一个可变引用
或任意数量的不可变引用。</li>
<li data-x-en="References must always be valid.">引用必须始终有效。</li>
</ul>
<p data-x-en="With references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime. With references, if you break these rules, you’ll get a compiler error. With RefCell<T>, if you break these rules, your program will panic and exit.">使用引用和<code>Box&lt;T&gt;</code>，借用规则的不变性在编译时被强制执行。使用<code>RefCell&lt;T&gt;</code>，这些不变性在<em>运行时</em>被强制执行。使用引用时，如果你违反了这些规则，你会得到一个编译器错误。使用<code>RefCell&lt;T&gt;</code>时，如果你违反了这些规则，你的程序将崩溃并退出。</p>
<p data-x-en="The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.">在编译时检查借用规则的优点是在开发过程中可以更早地捕获错误，并且由于所有分析都在事先完成，因此对运行时性能没有影响。基于这些原因，在大多数情况下，编译时检查借用规则是最佳选择，这也是为什么这是 Rust 的默认设置。</p>
<p data-x-en="The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would’ve been disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.">在运行时而不是编译时检查借用规则的优势在于，某些内存安全的场景得以允许，而这些场景在编译时检查中会被禁止。静态分析，如 Rust 编译器，本质上是保守的。有些代码的属性是无法通过分析代码来检测的：最著名的例子是停机问题，虽然这超出了本书的范围，但这是一个有趣的研究主题。</p>
<p data-x-en="Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The RefCell<T> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.">因为有些分析是不可能的，如果 Rust 编译器不能确定代码符合所有权规则，它可能会拒绝一个正确的程序；在这方面，它是保守的。如果 Rust 接受了一个不正确的程序，用户将无法信任 Rust 所提供的保证。然而，如果 Rust 拒绝了一个正确的程序，程序员会感到不便，但不会发生灾难性的情况。<code>RefCell&lt;T&gt;</code> 类型在你确信你的代码遵循了借用规则但编译器无法理解并保证这一点时非常有用。</p>
<p data-x-en="Similar to Rc<T>, RefCell<T> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context. We’ll talk about how to get the functionality of RefCell<T> in a multithreaded program in Chapter 16.">类似于<code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 仅用于单线程场景，如果你尝试在多线程上下文中使用它，将会在编译时出错。我们将在第16章讨论如何在多线程程序中实现 <code>RefCell&lt;T&gt;</code> 的功能。</p>
<p data-x-en="Here is a recap of the reasons to choose Box<T>, Rc<T>, or RefCell<T>:">以下是选择 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的原因总结：</p>
<ul>
<li data-x-en="Rc<T> enables multiple owners of the same data; Box<T> and RefCell<T> have single owners."><code>Rc&lt;T&gt;</code> 允许多个所有者拥有相同的数据；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li>
<li data-x-en="Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime."><code>Box&lt;T&gt;</code> 允许在编译时检查不可变或可变借用；<code>Rc&lt;T&gt;</code> 只允许在编译时检查不可变借用；<code>RefCell&lt;T&gt;</code> 允许在运行时检查不可变或可变借用。</li>
<li data-x-en="Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.">因为 <code>RefCell&lt;T&gt;</code> 允许在运行时检查的可变借用，所以即使 <code>RefCell&lt;T&gt;</code> 是不可变的，你也可以修改 <code>RefCell&lt;T&gt;</code> 内的值。</li>
</ul>
<p data-x-en="Mutating the value inside an immutable value is the interior mutability pattern. Let’s look at a situation in which interior mutability is useful and examine how it’s possible.">在不可变值内部改变值是<em>内部可变性</em>模式。让我们来看一个内部可变性有用的情况，并 examine 如何实现。</p>
<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value"><a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value">内部可变性：对不可变值的可变借用</a></h3>
<p data-x-en="A consequence of the borrowing rules is that when you have an immutable value, you can’t borrow it mutably. For example, this code won’t compile:">借用规则的一个后果是，当你有一个不可变的值时，你不能借用它为可变的。例如，这段代码无法编译：</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p data-x-en="If you tried to compile this code, you’d get the following error:">如果您尝试编译此代码，您会得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p data-x-en="However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using RefCell<T> is one way to get the ability to have interior mutability, but RefCell<T> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a panic! instead of a compiler error.">但是，在某些情况下，值在它的方法中自我变异是有用的，但对外部代码来说看起来是不可变的。值的方法之外的代码将无法变异该值。使用<code>RefCell&lt;T&gt;</code>是一种获得内部可变性的方法，但<code>RefCell&lt;T&gt;</code>并没有完全绕过借用规则：编译器中的借用检查器允许这种内部可变性，而借用规则是在运行时检查的。如果你违反了规则，你将得到一个<code>panic!</code>而不是编译器错误。</p>
<p data-x-en="Let’s work through a practical example where we can use RefCell<T> to mutate an immutable value and see why that is useful.">让我们通过一个实际的例子来使用 <code>RefCell&lt;T&gt;</code> 来修改不可变值，并看看为什么这很有用。</p>
<h4 id="a-use-case-for-interior-mutability-mock-objects"><a class="header" href="#a-use-case-for-interior-mutability-mock-objects">内部可变性的用例：模拟对象</a></h4>
<p data-x-en="Sometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert it’s implemented correctly. This placeholder type is called a test double. Think of it in the sense of a “stunt double” in filmmaking, where a person steps in and substitutes for an actor to do a particular tricky scene. Test doubles stand in for other types when we’re running tests. Mock objects are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.">有时在测试期间，程序员会使用一种类型代替另一种类型，<em>以便观察特定行为并断言其已正确实现</em>。这种占位符类型称为<em>测试替身</em>。可以将其理解为电影制作中的“替身”，即某人介入并代替演员完成特定的复杂场景。测试替身在我们运行测试时代表其他类型。<em>模拟对象</em>是特定类型的测试替身，它们记录测试期间发生的情况，以便您可以断言正确的操作已发生。</p>
<p data-x-en="Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.">Rust 没有以与其他语言相同的方式拥有对象，且 Rust 的标准库中没有像某些其他语言那样内置模拟对象功能。然而，你绝对可以创建一个结构体来实现与模拟对象相同的目的。</p>
<p data-x-en="Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.">这里是我们将测试的场景：我们将创建一个库，该库跟踪一个值相对于最大值，并根据当前值接近最大值的程度发送消息。这个库可以用于跟踪用户被允许调用的API数量的配额，例如。</p>
<p data-x-en="Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called Messenger. Listing 15-20 shows the library code:">我们的库将只提供跟踪一个值离最大值有多近以及在什么时间应该有什么消息的功能。使用我们库的应用程序将被期望提供发送消息的机制：应用程序可以将消息放入应用程序中，发送电子邮件，发送短信，或其他方式。库不需要知道这些细节。它只需要一个实现了我们提供的名为<code>Messenger</code>的特质的东西。清单15-20显示了库代码：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<figcaption>Listing 15-20: A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels</figcaption>
</figure>
<p data-x-en="One important part of this code is that the Messenger trait has one method called send that takes an immutable reference to self and the text of the message. This trait is the interface our mock object needs to implement so that the mock can be used in the same way a real object is. The other important part is that we want to test the behavior of the set_value method on the LimitTracker. We can change what we pass in for the value parameter, but set_value doesn’t return anything for us to make assertions on. We want to be able to say that if we create a LimitTracker with something that implements the Messenger trait and a particular value for max, when we pass different numbers for value, the messenger is told to send the appropriate messages.">这段代码的一个重要部分是 <code>Messenger</code> 特性有一个名为 <code>send</code> 的方法，该方法接受一个对 <code>self</code> 的不可变引用和消息的文本。这个特性是我们模拟对象需要实现的接口，以便模拟对象可以像真实对象一样使用。另一个重要部分是我们想要测试 <code>LimitTracker</code> 上 <code>set_value</code> 方法的行为。我们可以改变传递给 <code>value</code> 参数的值，但 <code>set_value</code> 不返回任何内容供我们进行断言。我们希望能够说，如果我们使用实现了 <code>Messenger</code> 特性的对象和特定的 <code>max</code> 值创建一个 <code>LimitTracker</code>，当我们传递不同的 <code>value</code> 数值时，信使会被告知发送适当的消息。</p>
<p data-x-en="We need a mock object that, instead of sending an email or text message when we call send, will only keep track of the messages it’s told to send. We can create a new instance of the mock object, create a LimitTracker that uses the mock object, call the set_value method on LimitTracker, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won’t allow it:">我们需要一个模拟对象，当我们在调用<code>send</code>时，它不会发送电子邮件或短信，而只会记录它被告知要发送的消息。我们可以创建一个模拟对象的新实例，创建一个使用模拟对象的<code>LimitTracker</code>，在<code>LimitTracker</code>上调用<code>set_value</code>方法，然后检查模拟对象是否具有我们期望的消息。列表15-21展示了一次尝试实现这样一个模拟对象的尝试，但借用检查器不允许这样做：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-21: An attempt to implement a <code>MockMessenger</code> that isn’t allowed by the borrow checker</figcaption>
</figure>
<p data-x-en="This test code defines a MockMessenger struct that has a sent_messages field with a Vec of String values to keep track of the messages it’s told to send. We also define an associated function new to make it convenient to create new MockMessenger values that start with an empty list of messages. We then implement the Messenger trait for MockMessenger so we can give a MockMessenger to a LimitTracker. In the definition of the send method, we take the message passed in as a parameter and store it in the MockMessenger list of sent_messages.">这个测试代码定义了一个 <code>MockMessenger</code> 结构体，它有一个 <code>sent_messages</code> 字段，包含一个 <code>Vec</code> 的 <code>String</code> 值，用于记录它被告知要发送的消息。我们还定义了一个关联函数 <code>new</code>，以便于创建新的 <code>MockMessenger</code> 值，这些值从一个空的消息列表开始。然后我们为 <code>MockMessenger</code> 实现了 <code>Messenger</code> 特性，这样我们就可以将一个 <code>MockMessenger</code> 给 <code>LimitTracker</code>。在 <code>send</code> 方法的定义中，我们将作为参数传递的消息存储在 <code>MockMessenger</code> 的 <code>sent_messages</code> 列表中。</p>
<p data-x-en="In the test, we’re testing what happens when the LimitTracker is told to set value to something that is more than 75 percent of the max value. First, we create a new MockMessenger, which will start with an empty list of messages. Then we create a new LimitTracker and give it a reference to the new MockMessenger and a max value of 100. We call the set_value method on the LimitTracker with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the MockMessenger is keeping track of should now have one message in it.">在测试中，我们测试当 <code>LimitTracker</code> 被告知将 <code>value</code> 设置为超过 <code>max</code> 值的 75% 时会发生什么。首先，我们创建一个新的 <code>MockMessenger</code>，它将从一个空的消息列表开始。然后我们创建一个新的 <code>LimitTracker</code> 并给它一个指向新的 <code>MockMessenger</code> 的引用和一个 <code>max</code> 值 100。我们调用 <code>LimitTracker</code> 的 <code>set_value</code> 方法，将值设置为 80，这超过了 100 的 75%。然后我们断言 <code>MockMessenger</code> 跟踪的消息列表现在应该有一个消息。</p>
<p data-x-en="However, there’s one problem with this test, as shown here:">然而，这个测试有一个问题，如这里所示：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p data-x-en="We can’t modify the MockMessenger to keep track of the messages, because the send method takes an immutable reference to self. We also can’t take the suggestion from the error text to use &amp;mut self in both the impl method and the trait definition. We do not want to change the Messenger trait solely for the sake of testing. Instead, we need to find a way to make our test code work correctly with our existing design.">我们不能修改<code>MockMessenger</code>来跟踪消息，因为<code>send</code>方法接受一个不可变的<code>self</code>引用。我们也不能采纳错误文本中的建议，在<code>impl</code>方法和<code>trait</code>定义中都使用<code>&amp;mut self</code>。我们不希望为了测试而改变<code>Messenger</code>特质。相反，我们需要找到一种方法，使我们的测试代码与现有的设计正确地工作。</p>
<p data-x-en="This is a situation in which interior mutability can help! We’ll store the sent_messages within a RefCell<T>, and then the send method will be able to modify sent_messages to store the messages we’ve seen. Listing 15-22 shows what that looks like:">这是一个内部可变性可以提供帮助的情况！我们将 <code>sent_messages</code> 存储在 <code>RefCell&lt;T&gt;</code> 中，然后 <code>send</code> 方法将能够修改 <code>sent_messages</code> 以存储我们看到的消息。清单 15-22 显示了这看起来像什么：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner value while the outer value is considered immutable</figcaption>
</figure>
<p data-x-en="The sent_messages field is now of type RefCell<Vec<String>> instead of Vec<String>. In the new function, we create a new RefCell<Vec<String>> instance around the empty vector."><code>sent_messages</code> 字段现在是 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 类型，而不是 <code>Vec&lt;String&gt;</code>。在 <code>new</code> 函数中，我们在空向量周围创建了一个新的 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 实例。</p>
<p data-x-en="For the implementation of the send method, the first parameter is still an immutable borrow of self, which matches the trait definition. We call borrow_mut on the RefCell<Vec<String>> in self.sent_messages to get a mutable reference to the value inside the RefCell<Vec<String>>, which is the vector. Then we can call push on the mutable reference to the vector to keep track of the messages sent during the test.">对于 <code>send</code> 方法的实现，第一个参数仍然是 <code>self</code> 的不可变借用，这与特质定义匹配。我们在 <code>self.sent_messages</code> 中的 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 上调用 <code>borrow_mut</code> 以获取 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 内部值的可变引用，即向量。然后我们可以在向量的可变引用上调用 <code>push</code> 以记录测试期间发送的消息。</p>
<p data-x-en="The last change we have to make is in the assertion: to see how many items are in the inner vector, we call borrow on the RefCell<Vec<String>> to get an immutable reference to the vector.">我们最后需要做的更改是在断言中：为了查看内部向量中有多少个元素，我们在 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 上调用 <code>borrow</code> 以获取向量的不可变引用。</p>
<p data-x-en="Now that you’ve seen how to use RefCell<T>, let’s dig into how it works!">现在你已经看到了如何使用<code>RefCell&lt;T&gt;</code>，让我们深入探讨它是如何工作的！</p>
<h4 id="keeping-track-of-borrows-at-runtime-with-refcellt"><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt">在运行时使用 <code>RefCell&lt;T&gt;</code> 跟踪借用</a></h4>
<p data-x-en="When creating immutable and mutable references, we use the &amp; and &amp;mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>. The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T>. Both types implement Deref, so we can treat them like regular references.">当创建不可变和可变引用时，我们分别使用<code>&amp;</code>和<code>&amp;mut</code>语法。对于<code>RefCell&lt;T&gt;</code>，我们使用<code>borrow</code>和<code>borrow_mut</code>方法，这些方法是属于<code>RefCell&lt;T&gt;</code>的安全API的一部分。<code>borrow</code>方法返回智能指针类型<code>Ref&lt;T&gt;</code>，而<code>borrow_mut</code>返回智能指针类型<code>RefMut&lt;T&gt;</code>。这两种类型都实现了<code>Deref</code>，因此我们可以像处理普通引用一样处理它们。</p>
<p data-x-en="The RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active. Every time we call borrow, the RefCell<T> increases its count of how many immutable borrows are active. When a Ref<T> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time."><code>RefCell&lt;T&gt;</code> 跟踪当前活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针的数量。每次我们调用 <code>borrow</code> 时，<code>RefCell&lt;T&gt;</code> 会增加其活跃的不可变借用的数量。当一个 <code>Ref&lt;T&gt;</code> 值超出作用域时，不可变借用的数量会减少一个。就像编译时借用规则一样，<code>RefCell&lt;T&gt;</code> 允许我们在任何时候拥有多个不可变借用或一个可变借用。</p>
<p data-x-en="If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of RefCell<T> will panic at runtime. Listing 15-23 shows a modification of the implementation of send in Listing 15-22. We’re deliberately trying to create two mutable borrows active for the same scope to illustrate that RefCell<T> prevents us from doing this at runtime.">如果我们尝试违反这些规则，而不是像使用引用时那样得到编译器错误，<code>RefCell&lt;T&gt;</code> 的实现将在运行时引发恐慌。列表 15-23 显示了对列表 15-22 中 <code>send</code> 实现的修改。我们故意尝试在同一作用域内创建两个可变借用，以说明 <code>RefCell&lt;T&gt;</code> 会在运行时阻止我们这样做。</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 15-23: Creating two mutable references in the same scope to see that <code>RefCell&lt;T&gt;</code> will panic</figcaption>
</figure>
<p data-x-en="We create a variable one_borrow for the RefMut<T> smart pointer returned from borrow_mut. Then we create another mutable borrow in the same way in the variable two_borrow. This makes two mutable references in the same scope, which isn’t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:">我们创建一个变量 <code>one_borrow</code> 用于从 <code>borrow_mut</code> 返回的 <code>RefMut&lt;T&gt;</code> 智能指针。然后我们以相同的方式在变量 <code>two_borrow</code> 中创建另一个可变借用。这在同一作用域内创建了两个可变引用，这是不允许的。当我们运行库的测试时，清单 15-23 中的代码将编译没有任何错误，但测试将失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p data-x-en="Notice that the code panicked with the message already borrowed: BorrowMutError. This is how RefCell<T> handles violations of the borrowing rules at runtime.">请注意，代码以消息 <code>already borrowed: BorrowMutError</code> 恐慌。这就是 <code>RefCell&lt;T&gt;</code> 在运行时处理借用规则违规的方式。</p>
<p data-x-en="Choosing to catch borrowing errors at runtime rather than compile time, as we’ve done here, means you’d potentially be finding mistakes in your code later in the development process: possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using RefCell<T> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you’re using it in a context where only immutable values are allowed. You can use RefCell<T> despite its trade-offs to get more functionality than regular references provide.">选择在运行时而不是编译时捕获借用错误，如我们在这里所做的，意味着你可能会在开发过程的后期才发现代码中的错误：可能直到你的代码被部署到生产环境。此外，由于在运行时而不是编译时跟踪借用，你的代码会因此承担一小部分运行时性能损失。然而，使用<code>RefCell&lt;T&gt;</code>可以使你在仅允许不可变值的上下文中编写一个可以修改自身以跟踪其已看到的消息的模拟对象。尽管<code>RefCell&lt;T&gt;</code>存在权衡，你仍然可以使用它来获得比普通引用更多的功能。</p>
<h3 id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">通过结合 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 拥有可变数据的多个所有者</a></h3>
<p data-x-en="A common way to use RefCell<T> is in combination with Rc<T>. Recall that Rc<T> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!">使用 <code>RefCell&lt;T&gt;</code> 的常见方法是与 <code>Rc&lt;T&gt;</code> 结合使用。回想一下，<code>Rc&lt;T&gt;</code> 让你拥有某些数据的多个所有者，但它只提供对该数据的不可变访问。如果你有一个持有 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code>，你可以获得一个可以有多个所有者 <em>并且</em> 可以修改的值！</p>
<p data-x-en="For example, recall the cons list example in Listing 15-18 where we used Rc<T> to allow multiple lists to share ownership of another list. Because Rc<T> holds only immutable values, we can’t change any of the values in the list once we’ve created them. Let’s add in RefCell<T> to gain the ability to change the values in the lists. Listing 15-24 shows that by using a RefCell<T> in the Cons definition, we can modify the value stored in all the lists:">例如，回想一下列表 15-18 中的 cons 列表示例，我们在其中使用了 <code>Rc&lt;T&gt;</code> 以允许多个列表共享另一个列表的所有权。由于 <code>Rc&lt;T&gt;</code> 仅持有不可变值，因此我们一旦创建了列表中的值就无法更改它们。让我们添加 <code>RefCell&lt;T&gt;</code> 以获得更改列表中值的能力。列表 15-24 显示，通过在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code>，我们可以修改所有列表中存储的值：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<figcaption>Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a <code>List</code> that we can mutate</figcaption>
</figure>
<p data-x-en="We create a value that is an instance of Rc<RefCell<i32>> and store it in a variable named value so we can access it directly later. Then we create a List in a with a Cons variant that holds value. We need to clone value so both a and value have ownership of the inner 5 value rather than transferring ownership from value to a or having a borrow from value.">我们创建一个 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 的实例值，并将其存储在一个名为 <code>value</code> 的变量中，以便稍后可以直接访问它。然后我们在 <code>a</code> 中创建一个包含 <code>value</code> 的 <code>Cons</code> 变体的 <code>List</code>。我们需要克隆 <code>value</code>，以便 <code>a</code> 和 <code>value</code> 都拥有内部 <code>5</code> 值的所有权，而不是将所有权从 <code>value</code> 转移到 <code>a</code> 或让 <code>a</code> 从 <code>value</code> 借用。</p>
<p data-x-en="We wrap the list a in an Rc<T> so that when we create lists b and c, they can both refer to a, which is what we did in Listing 15-18.">我们将列表 <code>a</code> 包装在 <code>Rc&lt;T&gt;</code> 中，这样当我们创建列表 <code>b</code> 和 <code>c</code> 时，它们都可以引用 <code>a</code>，这就是我们在示例 15-18 中所做的。</p>
<p data-x-en="After we’ve created the lists in a, b, and c, we want to add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature we discussed in Chapter 5 (see “Where’s the -> Operator?”) to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.">在创建了 <code>a</code>、<code>b</code> 和 <code>c</code> 中的列表后，我们希望将 10 加到 <code>value</code> 中的值。我们通过调用 <code>value</code> 上的 <code>borrow_mut</code> 方法来实现这一点，该方法使用我们在第 5 章中讨论的自动解引用功能（参见 <a href="ch05-03-method-syntax.html#wheres-the---operator">“<code>-&gt;</code> 运算符在哪里？”</a><!-- ignore -->）来解引用 <code>Rc&lt;T&gt;</code> 到内部的 <code>RefCell&lt;T&gt;</code> 值。<code>borrow_mut</code> 方法返回一个 <code>RefMut&lt;T&gt;</code> 智能指针，我们对其使用解引用运算符并更改内部值。</p>
<p data-x-en="When we print a, b, and c, we can see that they all have the modified value of 15 rather than 5:">当我们打印<code>a</code>，<code>b</code>，和<code>c</code>时，我们可以看到它们都具有修改后的值15而不是5：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p data-x-en="This technique is pretty neat! By using RefCell<T>, we have an outwardly immutable List value. But we can use the methods on RefCell<T> that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures. Note that RefCell<T> does not work for multithreaded code! Mutex<T> is the thread-safe version of RefCell<T> and we’ll discuss Mutex<T> in Chapter 16.">这种技术非常酷！通过使用 <code>RefCell&lt;T&gt;</code>，我们有一个表面上不可变的 <code>List</code> 值。但是我们可以使用 <code>RefCell&lt;T&gt;</code> 上的方法来访问其内部可变性，从而在需要时修改我们的数据。运行时的借用规则检查保护我们免受数据竞争的影响，有时为了数据结构的这种灵活性，牺牲一点速度是值得的。请注意，<code>RefCell&lt;T&gt;</code> 不适用于多线程代码！<code>Mutex&lt;T&gt;</code> 是 <code>RefCell&lt;T&gt;</code> 的线程安全版本，我们将在第 16 章讨论 <code>Mutex&lt;T&gt;</code>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>