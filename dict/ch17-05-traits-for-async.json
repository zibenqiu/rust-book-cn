{
  "Digging Into the Traits for Async": {
    "_translate": "<a class=\"header\" href=\"#digging-into-the-traits-for-async\">深入异步特性</a>",
    "_note": ""
  },
  "Future": {
    "_translate": "<a class=\"header\" href=\"#future\">未来</a>",
    "_note": ""
  },
  "Back in Futures and the Async Syntax, we noted that Future is a trait. Let’s start by taking a closer look at how it works. Here is how Rust defines a Future:": {
    "_translate": "在<a href=\"ch17-01-futures-and-syntax.html\">Futures 和异步语法</a>中，我们提到<code>Future</code>\n是一个特质。让我们先仔细看看它是如何工作的。以下是 Rust 如何定义<code>Future</code>：",
    "_note": ""
  },
  "Throughout the chapter, we’ve used the Future, Pin, Unpin, Stream, and StreamExt traits in various ways. So far, though, we’ve avoided digging too far into the details of how they work or how they fit together. Much of the time when writing Rust day to day, this is fine. Sometimes, though, you’ll hit situations where understanding a few more of these details matters. In this section, we’ll dig down enough further to help with those situations—while still leaving the really deep dive for other documentation!": {
    "_translate": "在本章中，我们以各种方式使用了<code>Future</code>、<code>Pin</code>、<code>Unpin</code>、<code>Stream</code>和<code>StreamExt</code>特质。然而，到目前为止，我们还没有深入探讨它们的工作原理或它们是如何协同工作的。在日常编写Rust代码时，大多数情况下这样做是没问题的。但有时，您会遇到需要理解更多这些细节的情况。在本节中，我们将深入探讨<em>足够</em>多的细节以帮助处理这些情况——同时仍然将<em>真正</em>深入的内容留给其他文档！",
    "_note": ""
  },
  "That trait definition includes a bunch of new types and also some syntax we haven’t seen before, so let’s walk through the definition piece by piece.": {
    "_translate": "那个特征定义包括了一堆新的类型还有一些我们之前没见过的语法，所以让我们一步步地解析这个定义。",
    "_note": ""
  },
  "First, Future’s associated type Output says what the future resolves to. This is analogous to the Item associated type for the Iterator trait. Second, Future also has the poll method, which takes a special Pin reference for its self parameter and a mutable reference to a Context type, and returns a Poll<Self::Output>. We’ll talk a little more about Pin and Context later in the section. For now, let’s focus on what the method returns, the Poll type:": {
    "_translate": "首先，<code>Future</code> 的关联类型 <code>Output</code> 说明了未来的解析结果。\n这类似于 <code>Iterator</code> 特性中的 <code>Item</code> 关联类型。\n其次，<code>Future</code> 还有一个 <code>poll</code> 方法，该方法接受一个特殊的 <code>Pin</code>\n引用作为其 <code>self</code> 参数和一个可变的 <code>Context</code> 类型引用，\n并返回一个 <code>Poll&lt;Self::Output&gt;</code>。我们将在本节稍后讨论 <code>Pin</code> 和\n<code>Context</code>。现在，让我们先关注方法的返回值，\n即 <code>Poll</code> 类型：",
    "_note": ""
  },
  "This Poll type is similar to an Option: it has one variant which has a value (Ready(T)), and one which does not (Pending). It means something quite different, though! The Pending variant indicates that the future still has work to do, so the caller will need to check again later. The Ready variant indicates that the Future has finished its work and the T value is available.": {
    "_translate": "这个 <code>Poll</code> 类型类似于 <code>Option</code>：它有一个包含值的变体 (<code>Ready(T)</code>)，和一个不包含值的变体 (<code>Pending</code>)。然而，它的含义却大不相同！<code>Pending</code> 变体表示该未来还有工作要做，因此调用者需要稍后再次检查。<code>Ready</code> 变体表示 <code>Future</code> 已完成其工作，并且 <code>T</code> 值可用。",
    "_note": ""
  },
  "Note: With most futures, the caller should not call poll again after the future has returned Ready. Many futures will panic if polled again after becoming ready! Futures which are safe to poll again will say so explicitly in their documentation. This is similar to how Iterator::next behaves!": {
    "_translate": "注意：对于大多数 future，调用者不应在 future 返回 <code>Ready</code> 后再次调用 <code>poll</code>。许多 future 在变为就绪状态后再次被轮询时会 panic！可以在文档中明确说明可以再次轮询的 future。这类似于 <code>Iterator::next</code> 的行为！",
    "_note": ""
  },
  "Under the hood, when you see code which uses await, Rust compiles that to code which calls poll. If you look back at Listing 17-4, where we printed out the page title for a single URL once it resolved, Rust compiles it into something kind of (although not exactly) like this:": {
    "_translate": "在内部，当你看到使用 <code>await</code> 的代码时，Rust 会将其编译为调用 <code>poll</code> 的代码。如果你回顾一下列表 17-4，我们在其中打印出单个 URL 解析后的页面标题，Rust 会将其编译成类似这样的代码（虽然不完全相同）：",
    "_note": ""
  },
  "What should we do when the Future is still Pending? We need some way to try again… and again, and again, until the future is finally ready. In other words, a loop:": {
    "_translate": "当 <code>Future</code> 仍然是 <code>Pending</code> 时，我们应该怎么办？我们需要某种方法来尝试... 再次，再再次，直到未来最终准备好。换句话说，一个循环：",
    "_note": ""
  },
  "If Rust compiled it to exactly that code, though, every await would be blocking—exactly the opposite of what we were going for! Instead, Rust needs makes sure that the loop can hand off control to something which can pause work on this future and work on other futures and check this one again later. That “something” is an async runtime, and this scheduling and coordination work is one of the main jobs for a runtime.": {
    "_translate": "如果 Rust 将其编译为完全相同的代码，那么每个 <code>await</code> 都会是阻塞的——这与我们的目标完全相反！相反，Rust 需要确保循环可以将控制权交给某个可以暂停此未来的处理并处理其他未来并在稍后再次检查此未来的东西。这个“东西”是一个异步运行时，而这种调度和协调工作是运行时的主要任务之一。",
    "_note": ""
  },
  "The exact details of how a runtime does that are more than we will cover in even this deep dive section. The key here is to see the basic mechanic of futures: a runtime polls each future it is responsible for, putting it back to sleep when it is not yet ready.": {
    "_translate": "确切的细节关于运行时如何做到这一点超出了我们即使在这一深入探讨部分的范围。关键在于理解未来的基机制：运行时<em>轮询</em>每个它负责的未来，在它们尚未准备好时将其重新置于休眠状态。",
    "_note": ""
  },
  "Recall our description (in the Counting section) of waiting on rx.recv. The recv call returns a Future, and awaiting it polls it. In our initial discussion, we noted that a runtime will pause the future until it’s ready with either Some(message) or None when the channel closes. With our deeper understanding of Future in place, and specifically Future::poll, we can see how that works. The runtime knows the future isn’t ready when it returns Poll::Pending. Conversely, the runtime knows the future is ready and advances it when poll returns Poll::Ready(Some(message)) or Poll::Ready(None).": {
    "_translate": "回顾我们在<a href=\"ch17-02-concurrency-with-async.html\">计数</a>部分对等待<code>rx.recv</code>的描述。<code>recv</code>调用返回一个<code>Future</code>，并且等待它会轮询它。在我们最初的讨论中，我们提到运行时会暂停该未来对象，直到它准备好返回<code>Some(message)</code>或在通道关闭时返回<code>None</code>。有了我们对<code>Future</code>的更深入理解，特别是<code>Future::poll</code>，我们可以看到它是如何工作的。当返回<code>Poll::Pending</code>时，运行时知道未来对象尚未准备好。相反，当<code>poll</code>返回<code>Poll::Ready(Some(message))</code>或<code>Poll::Ready(None)</code>时，运行时知道未来对象已准备好并推进它。",
    "_note": ""
  },
  "Pinning and the Pin and Unpin Traits": {
    "_translate": "<a class=\"header\" href=\"#pinning-and-the-pin-and-unpin-traits\">固定和 Pin 与 Unpin 特性</a>",
    "_note": ""
  },
  "When we introduced the idea of pinning while working on Listing 17-16, we ran into a very gnarly error message. Here is the relevant part of it again:": {
    "_translate": "当我们介绍在处理清单 17-16 时固定的概念时，遇到了一个非常棘手的错误信息。以下是它相关部分的再次展示：",
    "_note": ""
  },
  "When we read this error message carefully, it not only tells us that we need to pin the values, but also tells us why pinning is required. The trpl::join_all function returns a struct called JoinAll. That struct is generic over a type F, which is constrained to implement the Future trait. Directly awaiting a future with await pins the future implicitly. That’s why we don’t need to use pin! everywhere we want to await futures.": {
    "_translate": "当我们仔细阅读这个错误信息时，它不仅告诉我们需要固定这些值，还告诉我们为什么需要固定。`<code>trpl::join_all</code>` 函数返回一个名为 `<code>JoinAll</code>` 的结构体。该结构体泛型于类型 `<code>F</code>`，该类型被约束为实现 `<code>Future</code>` 特性。直接使用 `<code>await</code>` 等待一个未来会隐式地固定该未来。这就是为什么我们在想要等待未来的地方不需要到处使用 `<code>pin!</code>`。",
    "_note": ""
  },
  "However, we’re not directly awaiting a future here. Instead, we construct a new future, JoinAll, by passing a collection of futures to the join_all function. The signature for join_all produces requires that the type of the items in the collection all implement the Future trait, and Box<T> only implements Future if the T that it wraps is a future which implements the Unpin trait.": {
    "_translate": "然而，我们在这里并不是直接等待一个未来。相反，我们通过将一个未来集合传递给 <code>join_all</code> 函数来构造一个新的未来，<code>JoinAll</code>。<code>join_all</code> 的签名要求集合中的项目类型都实现了 <code>Future</code> 特性，而 <code>Box&lt;T&gt;</code> 只有在其包装的 <code>T</code> 是一个实现了 <code>Unpin</code> 特性的未来时才实现 <code>Future</code>。",
    "_note": ""
  },
  "That’s a lot! But we can understand it, if we dive a little further into how the Future type actually works, in particular around pinning.": {
    "_translate": "那确实很多！但是，如果我们进一步探讨 <code>Future</code> 类型的工作原理，特别是关于 <em>固定</em> 的部分，我们就可以理解了。",
    "_note": ""
  },
  "Let’s look again at the definition of Future:": {
    "_translate": "让我们再次看看 <code>Future</code> 的定义：",
    "_note": ""
  },
  "The cx parameter and its Context type is the key to how a runtime actually knows when to check any given future, while still being lazy. The details of how that works are beyond the scope of this chapter, though: you generally only need to worry about it when writing a custom Future implementation.": {
    "_translate": "<code>cx</code> 参数及其 <code>Context</code> 类型是运行时实际知道何时检查任何给定的 future，同时仍然保持惰性化的关键。尽管如此，这些细节超出了本章的范围：通常只有在编写自定义 <code>Future</code> 实现时才需要关注这些。",
    "_note": ""
  },
  "Instead, we’ll focus on the type for self. This is the first time we’ve seen a method where self has a type annotation. A type annotation for self is similar to type annotations for other function parameters, with two key differences. First, when we specify the type of self in this way, we’re telling Rust what type self must be to call this method. Second, a type annotation on self can’t be just any type. It’s only allowed to be the type on which the method is implemented, a reference or smart pointer to that type, or a Pin wrapping a reference to that type. We’ll see more on this syntax in Chapter 18. For now, it’s enough to know that if we want to poll a future (to check whether it is Pending or Ready(Output)), we need a mutable reference to the type, which is wrapped in a Pin.": {
    "_translate": "相反，我们将关注 <code>self</code> 的类型。这是我们第一次看到一个方法中 <code>self</code> 有类型注解。<code>self</code> 的类型注解与其他函数参数的类型注解类似，但有两个关键区别。首先，当我们以这种方式指定 <code>self</code> 的类型时，我们是在告诉 Rust 调用此方法时 <code>self</code> 必须是什么类型。其次，<code>self</code> 的类型注解不能是任意类型。它只能是实现该方法的类型、该类型的引用或智能指针，或者是包装了该类型引用的 <code>Pin</code>。我们将在第 18 章中看到更多关于这种语法的内容。目前，知道如果我们想轮询一个未来（检查它是否为 <code>Pending</code> 或 <code>Ready(Output)</code>），我们需要一个被 <code>Pin</code> 包装的类型的可变引用就足够了。",
    "_note": ""
  },
  "Pin is a wrapper type. In some ways, it’s similar to the Box, Rc, and other smart pointer types we saw in Chapter 15, which also wrap other types. Unlike those, however, Pin only works with pointer types such as references (& and &mut) and smart pointers (Box, Rc, and so on). To be precise, Pin works with types which implement the Deref or DerefMut traits, which we covered in Chapter 15. You can think of this restriction as equivalent to only working with pointers, though, because implementing Deref or DerefMut means your type behaves similarly to a pointer type. Pin is also not a pointer itself, and it doesn’t have any behavior of its own the way Rc and Arc do with ref counting. It’s purely a tool the compiler can use to uphold the relevant guarantees, by wrapping pointers in the type.": {
    "_translate": "<code>Pin</code> 是一个包装类型。在某些方面，它类似于我们在第 15 章中看到的 <code>Box</code>、<code>Rc</code> 和其他智能指针类型，这些类型也包装了其他类型。然而，与这些不同的是，<code>Pin</code> 只与 <em>指针类型</em> 一起工作，例如引用 (<code>&amp;</code> 和 <code>&amp;mut</code>) 和智能指针 (<code>Box</code>、<code>Rc</code> 等)。具体来说，<code>Pin</code> 与实现了 <code>Deref</code> 或 <code>DerefMut</code> 特性的类型一起工作，我们在第 15 章中讨论了这些特性。你可以将这种限制视为等同于仅与指针一起工作，因为实现 <code>Deref</code> 或 <code>DerefMut</code> 意味着你的类型行为类似于指针类型。<code>Pin</code> 本身也不是指针，它没有像 <code>Rc</code> 和 <code>Arc</code> 那样具有引用计数的行为。它纯粹是编译器可以用来通过包装指针类型来维护相关保证的工具。",
    "_note": ""
  },
  "Recalling that await is implemented in terms of calls to poll, this starts to explain the error message we saw above—but that was in terms of Unpin, not Pin. So what exactly are Pin and Unpin, how do they relate, and why does Future need self to be in a Pin type to call poll?": {
    "_translate": "回想 <code>await</code> 是通过调用 <code>poll</code> 来实现的，这开始解释了我们上面看到的错误信息——但那是在 <code>Unpin</code> 的背景下，而不是 <code>Pin</code>。那么，<code>Pin</code> 和 <code>Unpin</code> 到底是什么，它们之间有什么关系，为什么 <code>Future</code> 需要 <code>self</code> 处于 <code>Pin</code> 类型中才能调用 <code>poll</code>？",
    "_note": ""
  },
  "In Our First Async Program, we described how a series of await points in a future get compiled into a state machine—and noted how the compiler helps make sure that state machine follows all of Rust’s normal rules around safety, including borrowing and ownership. To make that work, Rust looks at what data is needed between each await point and the next await point or the end of the async block. It then creates a corresponding variant in the state machine it creates. Each variant gets the access it needs to the data that will be used in that section of the source code, whether by taking ownership of that data or by getting a mutable or immutable reference to it.": {
    "_translate": "在<a href=\"ch17-01-futures-and-syntax.html#our-first-async-program\">我们的第一个异步程序</a>中，我们描述了未来中的一个系列的await点如何被编译成一个状态机——并指出编译器如何帮助确保该状态机遵循Rust关于安全性的所有常规规则，包括借用和所有权。为了使这一点生效，Rust会查看每个await点与下一个await点或异步块结束之间所需的数据。然后，它在创建的状态机中创建相应的变体。每个变体都会获得对该部分源代码中将使用的数据的访问权限，无论是通过获取该数据的所有权还是通过获取其可变或不可变引用。",
    "_note": ""
  },
  "So far so good: if we get anything wrong about the ownership or references in a given async block, the borrow checker will tell us. When we want to move around the future that corresponds to that block—like moving it into a Vec to pass to join_all, the way we did back in the “Working With Any Number of Futures” section—things get trickier.": {
    "_translate": "到目前为止一切顺利：如果我们对给定异步块中的所有权或引用有任何错误，借用检查器会告诉我们。当我们想要移动与该块对应的未来对象时——比如将其移动到<code>Vec</code>中以传递给<code>join_all</code>，就像我们在<a href=\"ch17-03-more-futures.html#working-with-any-number-of-futures\">“处理任意数量的未来对象”</a><!-- ignore -->部分所做的那样——事情会变得更复杂。",
    "_note": ""
  },
  "When we move a future—whether by pushing into a data structure to use as an iterator with join_all, or returning them from a function—that actually means moving the state machine Rust creates for us. And unlike most other types in Rust, the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant, as in Figure 17-4 (a simplified illustration to help you get a feel for the idea, rather than digging into what are often fairly complicated details).": {
    "_translate": "当我们移动一个未来——无论是通过将其推入数据结构以用作 <code>join_all</code> 的迭代器，还是从函数返回它们——这实际上意味着移动 Rust 为我们创建的状态机。与 Rust 中的大多数其他类型不同，Rust 为异步块创建的未来可以在任何给定变体的字段中最终包含对自身的引用，如图 17-4 所示（这是一个简化的图示，旨在帮助您理解这个概念，而不是深入探讨通常相当复杂的细节）。",
    "_note": ""
  },
  "By default, though, any object which has a reference to itself is unsafe to move, because references always point to the actual memory address of the thing they refer to. If you move the data structure itself, those internal references will be left pointing to the old location. However, that memory location is now invalid. For one thing, its value will not be updated when you make changes to the data structure. For another—and more importantly!—the computer is now free to reuse that memory for other things! You could end up reading completely unrelated data later.": {
    "_translate": "默认情况下，任何具有指向自身引用的对象在移动时都是不安全的，因为引用总是指向它们所引用对象的实际内存地址。如果你移动了数据结构本身，那些内部引用将仍然指向旧的位置。然而，那个内存位置现在是无效的。一方面，当你对数据结构进行更改时，其值不会被更新。另一方面，更重要的是！计算机现在可以自由地将该内存用于其他事情！你可能会在稍后读取完全不相关的数据。",
    "_note": ""
  },
  "In principle, the Rust compiler could try to update every reference to an object every time it gets moved. That would potentially be a lot of performance overhead, especially given there can be a whole web of references that need updating. On the other hand, if we could make sure the data structure in question doesn’t move in memory, we don’t have to update any references. This is exactly what Rust’s borrow checker requires: you can’t move an item which has any active references to it using safe code.": {
    "_translate": "原则上，Rust 编译器可以尝试在每次对象移动时更新每个对该对象的引用。这可能会带来大量的性能开销，特别是考虑到可能需要更新的引用网络。另一方面，如果我们能确保该数据结构 <em>不会在内存中移动</em>，我们就不需要更新任何引用。这正是 Rust 的借用检查器所要求的：你不能使用安全代码移动任何有活动引用的项。",
    "_note": ""
  },
  "Pin builds on that to give us the exact guarantee we need. When we pin a value by wrapping a pointer to that value in Pin, it can no longer move. Thus, if you have Pin<Box<SomeType>>, you actually pin the SomeType value, not the Box pointer. Figure 17-6 illustrates this:": {
    "_translate": "<code>Pin</code> 在此基础上为我们提供了所需的精确保证。当我们通过将指向该值的指针包装在 <code>Pin</code> 中来 <em>固定</em> 一个值时，该值将不能再移动。因此，如果你有 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>，你实际上固定的是 <code>SomeType</code> 值，<em>而不是</em> <code>Box</code> 指针。图 17-6 说明了这一点：",
    "_note": ""
  },
  "In fact, the Box pointer can still move around freely. Remember: we care about making sure the data ultimately being referenced stays in its place. If a pointer moves around, but the data it points to is in the same place, as in Figure 17-7, there’s no potential problem. (How you would do this with a Pin wrapping a Box is more than we’ll get into in this particular discussion, but it would make for a good exercise! If you look at the docs for the types as well as the std::pin module, you might be able to work out how you would do that.) The key is that the self-referential type itself cannot move, because it is still pinned.": {
    "_translate": "事实上，<code>Box</code> 指针仍然可以自由移动。记住：我们关心的是确保最终被引用的数据保持在原位。如果指针移动了，但其所指向的数据仍在同一位置，如图 17-7 所示，就没有潜在的问题。（如何使用 <code>Pin</code> 包装 <code>Box</code> 来实现这一点超出了我们当前讨论的范围，但这将是一个很好的练习！如果你查看这些类型的文档以及 <code>std::pin</code> 模块，你可能会弄清楚如何做到这一点。）关键是自引用类型本身不能移动，因为它仍然是固定的。",
    "_note": ""
  },
  "Unpin is a marker trait, similar to the Send and Sync traits we saw in Chapter 16. Recall that marker traits have no functionality of their own. They exist only to tell the compiler that it’s safe to use the type which implements a given trait in a particular context. Unpin informs the compiler that a given type does not need to uphold any particular guarantees about whether the value in question can be moved.": {
    "_translate": "<code>Unpin</code> 是一个标记特征，类似于我们在第 16 章中看到的 <code>Send</code> 和 <code>Sync</code> 特征。回想一下，标记特征本身没有任何功能。它们仅存在于告诉编译器，实现给定特征的类型在特定上下文中使用是安全的。<code>Unpin</code> 告知编译器，给定的类型不需要维持任何关于该值是否可以移动的特定保证。",
    "_note": ""
  },
  "However, most types are perfectly safe to move around, even if they happen to be behind a Pin pointer. We only need to think about pinning when items have internal references. Primitive values such as numbers and booleans don’t have any internal references, so they’re obviously safe. Neither do most types you normally work with in Rust. A Vec, for example, doesn’t have any internal references it needs to keep up to date this way, so you can move it around without worrying. If you have a Pin<Vec<String>>, you’d have to do everything via the safe but restrictive APIs provided by Pin, even though a Vec<String> is always safe to move if there are no other references to it. We need a way to tell the compiler that it’s actually just fine to move items around in cases such as these. For that, we have Unpin.": {
    "_translate": "然而，大多数类型即使在 <code>Pin</code> 指针后面也是完全安全的。我们只有在项目具有内部引用时才需要考虑固定。像数字和布尔值这样的原始值没有任何内部引用，因此它们显然是安全的。你通常在 Rust 中使用的大多数类型也是如此。例如，<code>Vec</code> 没有任何需要保持更新的内部引用，因此你可以随意移动它而无需担心。如果你有一个 <code>Pin&lt;Vec&lt;String&gt;&gt;</code>，即使 <code>Vec&lt;String&gt;</code> 在没有其他引用的情况下总是可以安全移动的，你也必须通过 <code>Pin</code> 提供的安全但受限的 API 来做所有事情。我们需要一种方法来告诉编译器在这些情况下实际上可以安全地移动项目。为此，我们有 <code>Unpin</code>。",
    "_note": ""
  },
  "Just as with Send and Sync, the compiler implements Unpin automatically for all types where it can prove it is safe. The special case, again similar to Send and Sync, is the case where Unpin is not implemented for a type. The notation for this is impl !Unpin for SomeType, where SomeType is the name of a type which does need to uphold those guarantees to be safe whenever a pointer to that type is used in a Pin.": {
    "_translate": "正如对 <code>Send</code> 和 <code>Sync</code> 一样，编译器会自动为所有可以证明安全的类型实现 <code>Unpin</code>。特殊情况，同样类似于 <code>Send</code> 和 <code>Sync</code>，是 <code>Unpin</code> <em>未</em> 为某个类型实现的情况。这种表示法是 <code>impl !Unpin for SomeType</code>，其中 <code>SomeType</code> 是需要在使用该类型的指针时确保这些保证以确保安全的类型的名称。",
    "_note": ""
  },
  "In other words, there are two things to keep in mind about the relationship between Pin and Unpin. First, Unpin is the “normal” case, and !Unpin is the special case. Second, whether a type implements Unpin or !Unpin only matters when using a pinned pointer to that type like Pin<&mut SomeType>.": {
    "_translate": "换句话说，关于 <code>Pin</code> 和 <code>Unpin</code> 之间的关系，有两点需要注意。首先，<code>Unpin</code> 是“正常”情况，而 <code>!Unpin</code> 是特殊情况。其次，一个类型是否实现了 <code>Unpin</code> 或 <code>!Unpin</code> <em>仅在</em> 使用指向该类型的固定指针（如 <code>Pin&lt;&amp;mut SomeType&gt;</code>）时才重要。",
    "_note": ""
  },
  "To make that concrete, think about a String: it has a length and the Unicode characters which make it up. We can wrap a String in Pin, as seen in Figure 17-8. However, String automatically implements Unpin, the same as most other types in Rust.": {
    "_translate": "为了具体说明这一点，考虑一个 <code>String</code>：它有一个长度和组成它的 Unicode 字符。我们可以在 <code>Pin</code> 中包装一个 <code>String</code>，如图 17-8 所示。然而，<code>String</code> 自动实现了 <code>Unpin</code>，就像 Rust 中的大多数其他类型一样。",
    "_note": ""
  },
  "As a result, we can do things which would be illegal if String implemented !Unpin instead, such as replace one string with another at the exact same location in memory as in Figure 17-9. This doesn’t violate the Pin contract, because String has no internal references that make it unsafe to move around! That is precisely why it implements Unpin rather than !Unpin.": {
    "_translate": "因此，我们可以做一些如果 <code>String</code> 实现了 <code>!Unpin</code> 就会非法的事情，比如在内存中的确切相同位置用另一个字符串替换一个字符串，如图17-9所示。这不会违反 <code>Pin</code> 协议，因为 <code>String</code> 没有内部引用使其移动不安全！这正是它实现 <code>Unpin</code> 而不是 <code>!Unpin</code> 的原因。",
    "_note": ""
  },
  "Pin and Unpin are mostly important for building lower-level libraries, or when you’re building a runtime itself, rather than for day to day Rust code. When you see these traits in error messages, though, now you’ll have a better idea of how to fix the code!": {
    "_translate": "<code>Pin</code> 和 <code>Unpin</code> 主要对于构建底层库或构建运行时本身非常重要，而不是用于日常的 Rust 代码。当你在错误消息中看到这些特征时，现在你将更好地了解如何修复代码！",
    "_note": ""
  },
  "Note: This combination of Pin and Unpin allows a whole class of complex types to be safe in Rust which are otherwise difficult to implement because they’re self-referential. Types which require Pin show up most commonly in async Rust today, but you might—very rarely!—see it in other contexts, too.": {
    "_translate": "注意：这种 <code>Pin</code> 和 <code>Unpin</code> 的组合使得一类复杂的类型在 Rust 中是安全的，而这些类型由于是自引用的，通常很难实现。需要 <code>Pin</code> 的类型在今天的异步 Rust 中最常见，但你也可能——非常罕见！——在其他上下文中看到它。",
    "_note": ""
  },
  "Now we know enough to understand the errors reported for that join_all call from back in Listing 17-17. We originally tried to move the futures produced by async blocks into a Vec<Box<dyn Future<Output = ()>>>, but as we’ve seen, those futures may have internal references, so they don’t implement Unpin. They need to be pinned, and then we can pass the Pin type into the Vec, confident that the underlying data in the futures will not be moved.": {
    "_translate": "现在我们已经了解了足够的知识，可以理解在清单 17-17 中报告的 <code>join_all</code> 调用的错误。我们最初尝试将由 async 块生成的 future 移动到 <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code> 中，但正如我们所见，这些 future 可能有内部引用，因此它们不实现 <code>Unpin</code>。它们需要被固定，然后我们可以将 <code>Pin</code> 类型传递给 <code>Vec</code>，确信 future 中的底层数据 <em>不会</em> 被移动。",
    "_note": ""
  },
  "The specifics of how Pin and Unpin work, and the rules they’re required to uphold, are covered extensively in the API documentation for std::pin, so if you’d like to understand them more deeply, that’s a great place to start.": {
    "_translate": "<code>Pin</code> 和 <code>Unpin</code> 的具体工作方式以及它们需要遵守的规则，在 <code>std::pin</code> 的 API 文档中进行了详尽的介绍，因此如果你想更深入地了解它们，这是一个很好的起点。",
    "_note": ""
  },
  "If you want to understand how things work “under the hood” in even more detail, the official Asynchronous Programming in Rust book has you covered:": {
    "_translate": "如果您想更详细地了解“底层”工作原理，官方的<a href=\"https://rust-lang.github.io/async-book/\"><em>Rust 中的异步编程</em></a>书籍会为您解答：",
    "_note": ""
  },
  "The Stream Trait": {
    "_translate": "<a class=\"header\" href=\"#the-stream-trait\">流特质</a>",
    "_note": ""
  },
  "Now that we have a deeper grasp on the Future, Pin, and Unpin traits, we can turn our attention to the Stream trait. As described in the section introducing streams, streams are similar to asynchronous iterators. Unlike Iterator and Future, there is no definition of a Stream trait in the standard library as of the time of writing, but there is a very common definition from the futures crate used throughout the ecosystem.": {
    "_translate": "现在我们对 <code>Future</code>、<code>Pin</code> 和 <code>Unpin</code> 特性有了更深入的了解，我们可以将注意力转向 <code>Stream</code> 特性。正如在介绍流的部分所述，流类似于异步迭代器。与 <code>Iterator</code> 和 <code>Future</code> 不同，截至本文撰写时，标准库中没有 <code>Stream</code> 特性的定义，但 <code>futures</code> 库中有一个非常常见的定义，在整个生态系统中广泛使用。",
    "_note": ""
  },
  "Let’s review the definitions of the Iterator and Future traits, so we can build up to how a Stream trait that merges them together might look. From Iterator, we have the idea of a sequence: its next method provides an Option<Self::Item>. From Future, we have the idea of readiness over time: its poll method provides a Poll<Self::Output>. To represent a sequence of items which become ready over time, we define a Stream trait which puts those features together:": {
    "_translate": "让我们回顾一下 <code>Iterator</code> 和 <code>Future</code> 特性的定义，这样我们就可以逐步了解如何将它们合并到一个 <code>Stream</code> 特性中。从 <code>Iterator</code> 中，我们有序列的概念：其 <code>next</code> 方法提供一个 <code>Option&lt;Self::Item&gt;</code>。从 <code>Future</code> 中，我们有随时间变化的准备状态的概念：其 <code>poll</code> 方法提供一个 <code>Poll&lt;Self::Output&gt;</code>。为了表示随时间变化的项目序列，我们定义了一个 <code>Stream</code> 特性，将这些特性结合在一起：",
    "_note": ""
  },
  "Stream also defines a method to get those items. We call it poll_next, to make it clear that it polls in the same way Future::poll does and produces a sequence of items in the same way Iterator::next does. Its return type combines Poll with Option. The outer type is Poll, because it has to be checked for readiness, just as a future does. The inner type is Option, because it needs to signal whether there are more messages, just as an iterator does.": {
    "_translate": "<code>Stream</code> 还定义了一个方法来获取这些项。我们称之为 <code>poll_next</code>，以明确它以与 <code>Future::poll</code> 相同的方式进行轮询，并以与 <code>Iterator::next</code> 相同的方式生成一系列项。其返回类型将 <code>Poll</code> 与 <code>Option</code> 结合在一起。外部类型是 <code>Poll</code>，因为它需要像未来一样检查就绪状态。内部类型是 <code>Option</code>，因为它需要像迭代器一样指示是否还有更多消息。",
    "_note": ""
  },
  "The Stream trait defines an associated type Item for the type of the items produced by the stream. This is similar to Iterator: there may be zero to many of these, and unlike Future, where there is always a single Output (even if it’s the unit type ()).": {
    "_translate": "<code>Stream</code> 特性定义了一个关联类型 <code>Item</code>，用于表示流产生的项的类型。这与 <code>Iterator</code> 类似：可能有零个到多个这样的项，而与 <code>Future</code> 不同，<code>Future</code> 始终只有一个 <code>Output</code>（即使它是单元类型 <code>()</code>）。",
    "_note": ""
  },
  "Something very similar to this will likely end up standardized as part of Rust’s standard library. In the meantime, it’s part of the toolkit of most runtimes, so you can rely on it, and everything we cover below should generally apply!": {
    "_translate": "与这非常相似的内容很可能会成为 Rust 标准库的一部分。在此期间，它已经是大多数运行时工具包的一部分，因此你可以依赖它，下面涵盖的所有内容通常都适用！",
    "_note": ""
  },
  "Note: The actual definition we used earlier in the chapter looks slightly different than this, because it supports versions of Rust which did not yet support using async functions in traits. As a result, it looks like this:": {
    "_translate": "注意：我们在本章前面使用的实际定义与此略有不同，因为它支持尚未支持在特质中使用异步函数的 Rust 版本。因此，它看起来像这样：",
    "_note": ""
  },
  "That Next type is a struct which implements Future and gives a way to name the lifetime of the reference to self with Next<'_, Self>, so that await can work with this method!": {
    "_translate": "那个 <code>Next</code> 类型是一个 <code>struct</code>，它实现了 <code>Future</code> 并提供了一种方法来命名对 <code>self</code> 的引用的生命周期，使用 <code>Next&lt;'_, Self&gt;</code>，这样 <code>await</code> 就可以与这个方法一起工作！",
    "_note": ""
  },
  "In the example we saw in the section on streaming, though, we didn’t use poll_next or Stream, but instead used next and StreamExt. We could work directly in terms of the poll_next API by hand-writing our own Stream state machines, of course, just as we could work with futures directly via their poll method. Using await is much nicer, though, so the StreamExt trait supplies the next method so we can do just that.": {
    "_translate": "在我们之前在流处理部分看到的例子中，我们并没有使用<code>poll_next</code> <em>或</em> <code>Stream</code>，而是使用了<code>next</code>和<code>StreamExt</code>。我们<em>可以</em>通过手动编写自己的<code>Stream</code>状态机来直接使用<code>poll_next</code> API，当然，我们<em>也可以</em>通过它们的<code>poll</code>方法直接处理未来对象。然而，使用<code>await</code>要方便得多，因此<code>StreamExt</code>特质提供了<code>next</code>方法，使我们能够这样做。",
    "_note": ""
  },
  "The StreamExt trait is also the home of all the interesting methods available to use with streams. StreamExt is automatically implemented for every type which implements Stream, but these traits are defined separately so that the community can iterate on the foundational trait distinctly from the convenience APIs.": {
    "_translate": "<code>StreamExt</code> 特性也是所有可用于流的有趣方法的所在地。<code>StreamExt</code> 会自动为每个实现了 <code>Stream</code> 的类型实现，但这些特性是单独定义的，以便社区可以独立于基础特性迭代便利性 API。",
    "_note": ""
  },
  "That’s all we’re going to cover for the lower-level details on these traits. To wrap up, let’s consider how futures (including streams), tasks, and threads all fit together!": {
    "_translate": "这就是我们对这些特质的底层细节的所有介绍。为了总结，让我们考虑一下未来（包括流）、任务和线程是如何协同工作的！",
    "_note": ""
  },
  "In the version of StreamExt used in the trpl crate, the trait not only defines the next method, it also supplies an implementation of next, which correctly handles the details of calling Stream::poll_next. This means that even when you need to write your own streaming data type, you only have to implement Stream, and then anyone who uses your data type can use StreamExt and its methods with it automatically.": {
    "_translate": "在用于 <code>trpl</code> crate 的 <code>StreamExt</code> 版本中，该 trait 不仅定义了 <code>next</code> 方法，还提供了 <code>next</code> 方法的实现，该实现正确处理了调用 <code>Stream::poll_next</code> 的细节。这意味着，即使你需要编写自己的流数据类型，你也 <em>只需</em> 实现 <code>Stream</code>，然后任何使用你数据类型的人可以自动使用 <code>StreamExt</code> 及其方法。",
    "_note": ""
  },
  "Digging Into the Traits for Async - The Rust Programming Language": {
    "_translate": "深入异步特质 - 《Rust编程语言》",
    "_note": ""
  },
  "Chapter 2: Under the Hood: Executing Futures and Tasks": {
    "_translate": "<a href=\"https://rust-lang.github.io/async-book/02_execution/01_chapter.html\">第 2 章：幕后：执行 Future 和任务</a>",
    "_note": ""
  },
  "Chapter 4: Pinning": {
    "_translate": "<a href=\"https://rust-lang.github.io/async-book/04_pinning/01_chapter.html\">第 4 章：固定</a>",
    "_note": ""
  },
  "If Rust compiled it to exactly that code, though, every await would be blocking—exactly the opposite of what we were going for! Instead, Rust makes sure that the loop can hand off control to something which can pause work on this future and work on other futures and check this one again later. That “something” is an async runtime, and this scheduling and coordination work is one of the main jobs for a runtime.": {
    "_translate": "如果 Rust 将其编译为完全相同的代码，那么每个 <code>await</code> 都会是阻塞的——这与我们的目标完全相反！相反，Rust 确保循环可以将控制权交给某个可以暂停此未来的处理并处理其他未来并在稍后再次检查此未来的东西。这个“东西”是一个异步运行时，而这种调度和协调工作是运行时的主要职责之一。",
    "_note": ""
  },
  "However, we’re not directly awaiting a future here. Instead, we construct a new future, JoinAll, by passing a collection of futures to the join_all function. The signature for join_all requires that the type of the items in the collection all implement the Future trait, and Box<T> only implements Future if the T that it wraps is a future which implements the Unpin trait.": {
    "_translate": "然而，我们在这里并不是直接等待一个未来。相反，我们通过将一个未来集合传递给 <code>join_all</code> 函数来构建一个新的未来，<code>JoinAll</code>。<code>join_all</code> 的签名要求集合中的项目类型都实现 <code>Future</code> 特性，而 <code>Box&lt;T&gt;</code> 只有在其包装的 <code>T</code> 是一个实现 <code>Unpin</code> 特性的未来时才实现 <code>Future</code>。",
    "_note": ""
  },
  "Back in “Futures and the Async Syntax”, we noted that Future is a trait. Let’s start by taking a closer look at how it works. Here is how Rust defines a Future:": {
    "_translate": "在<a href=\"ch17-01-futures-and-syntax.html\">“Futures 和异步语法”</a><!-- ignore -->中，我们\n提到 <code>Future</code> 是一个特质。让我们先仔细看看它是如何工作的。以下是 Rust 如何定义 <code>Future</code>：",
    "_note": ""
  },
  "A Closer Look at the Traits for Async - The Rust Programming Language": {
    "_translate": "更深入地了解异步特征 - 《Rust编程语言》",
    "_note": ""
  },
  "A Closer Look at the Traits for Async": {
    "_translate": "<a class=\"header\" href=\"#a-closer-look-at-the-traits-for-async\">深入探讨异步特性</a>",
    "_note": ""
  },
  "The Future Trait": {
    "_translate": "<a class=\"header\" href=\"#the-future-trait\">《<code>Future</code> 特性》</a>",
    "_note": ""
  },
  "Throughout the chapter, we’ve used the Future, Pin, Unpin, Stream, and StreamExt traits in various ways. So far, though, we’ve avoided getting too far into the details of how they work or how they fit together, which is fine most of the time for your day-to-day Rust work. Sometimes, though, you’ll encounter situations where you’ll need to understand a few more of these details. In this section, we’ll dig in just enough to help in those scenarios, still leaving the really deep dive for other documentation.": {
    "_translate": "在本章中，我们以各种方式使用了<code>Future</code>、<code>Pin</code>、<code>Unpin</code>、<code>Stream</code>和<code>StreamExt</code>特质。到目前为止，我们避免深入探讨它们的工作原理或它们如何协同工作，这在大多数日常的Rust工作中是完全可以的。然而，有时你会遇到需要了解这些细节的情况。在本节中，我们将深入探讨足够的内容以帮助解决这些情况，但仍将更深入的探讨留给其他文档。",
    "_note": ""
  },
  "Let’s start by taking a closer look at how the Future trait works. Here’s how Rust defines it:": {
    "_translate": "让我们先仔细看看 <code>Future</code> 特性是如何工作的。以下是 Rust 对其的定义：",
    "_note": ""
  },
  "This Poll type is similar to an Option. It has one variant that has a value, Ready(T), and one which does not, Pending. Poll means something quite different from Option, though! The Pending variant indicates that the future still has work to do, so the caller will need to check again later. The Ready variant indicates that the future has finished its work and the T value is available.": {
    "_translate": "这个 <code>Poll</code> 类型类似于 <code>Option</code>。它有一个包含值的变体 <code>Ready(T)</code>，以及一个不包含值的变体 <code>Pending</code>。不过，<code>Poll</code> 与 <code>Option</code> 的含义大不相同！<code>Pending</code> 变体表示未来还有工作要做，因此调用者需要稍后再次检查。<code>Ready</code> 变体表示未来已经完成了其工作，<code>T</code> 值可用。",
    "_note": ""
  },
  "First, Future’s associated type Output says what the future resolves to. This is analogous to the Item associated type for the Iterator trait. Second, Future also has the poll method, which takes a special Pin reference for its self parameter and a mutable reference to a Context type, and returns a Poll<Self::Output>. We’ll talk more about Pin and Context in a moment. For now, let’s focus on what the method returns, the Poll type:": {
    "_translate": "首先，<code>Future</code> 的关联类型 <code>Output</code> 表示未来将解析为何种值。\n这类似于 <code>Iterator</code> 特性中的 <code>Item</code> 关联类型。\n其次，<code>Future</code> 还具有 <code>poll</code> 方法，该方法接受一个特殊的 <code>Pin</code>\n引用作为其 <code>self</code> 参数和一个可变的 <code>Context</code> 类型引用，\n并返回一个 <code>Poll&lt;Self::Output&gt;</code>。我们稍后会详细讨论 <code>Pin</code> 和\n<code>Context</code>。现在，让我们先关注该方法的返回值，\n即 <code>Poll</code> 类型：",
    "_note": ""
  },
  "Note: With most futures, the caller should not call poll again after the future has returned Ready. Many futures will panic if polled again after becoming ready. Futures that are safe to poll again will say so explicitly in their documentation. This is similar to how Iterator::next behaves.": {
    "_translate": "注意：对于大多数 future，调用者不应在 future 返回 <code>Ready</code> 后再次调用 <code>poll</code>。许多 future 在变为就绪状态后再次被轮询时会 panic。可以在文档中明确说明可以安全再次轮询的 future。这类似于 <code>Iterator::next</code> 的行为。",
    "_note": ""
  },
  "When you see code that uses await, Rust compiles it under the hood to code that calls poll. If you look back at Listing 17-4, where we printed out the page title for a single URL once it resolved, Rust compiles it into something kind of (although not exactly) like this:": {
    "_translate": "当你看到使用 <code>await</code> 的代码时，Rust 会在底层将其编译为调用 <code>poll</code> 的代码。如果你回顾一下清单 17-4，我们在其中打印出单个 URL 解析后的页面标题，Rust 会将其编译成类似这样的代码（虽然不完全相同）：",
    "_note": ""
  },
  "What should we do when the future is still Pending? We need some way to try again, and again, and again, until the future is finally ready. In other words, we need a loop:": {
    "_translate": "当我们遇到未来状态仍为<code>Pending</code>时，我们应该怎么办？我们需要某种方法尝试\n一次又一次，直到未来最终准备就绪。换句话说，\n我们需要一个循环：",
    "_note": ""
  },
  "If Rust compiled it to exactly that code, though, every await would be blocking—exactly the opposite of what we were going for! Instead, Rust makes sure that the loop can hand off control to something that can pause work on this future to work on other futures and then check this one again later. As we’ve seen, that something is an async runtime, and this scheduling and coordination work is one of its main jobs.": {
    "_translate": "如果 Rust 将其编译为完全相同的代码，那么每个 <code>await</code> 都会是阻塞的——这与我们的目标完全相反！相反，Rust 确保循环可以将控制权交给某个可以暂停此未来的处理以处理其他未来，然后稍后再检查此未来的东西。正如我们所见，这个东西是一个异步运行时，而这种调度和协调工作是它的主要职责之一。",
    "_note": ""
  },
  "The exact details of how a runtime does that are beyond the scope of this book, but the key is to see the basic mechanics of futures: a runtime polls each future it is responsible for, putting the future back to sleep when it is not yet ready.": {
    "_translate": "具体的运行时如何做到这一点的细节超出了本书的范围，\n但关键是了解未来的的基本机制：<em>运行时会轮询</em>它负责的每个未来，\n当未来尚未准备好时，将其重新置于休眠状态。",
    "_note": ""
  },
  "Earlier in the chapter, we described waiting on rx.recv. The recv call returns a future, and awaiting the future polls it. We noted that a runtime will pause the future until it’s ready with either Some(message) or None when the channel closes. With our deeper understanding of the Future trait, and specifically Future::poll, we can see how that works. The runtime knows the future isn’t ready when it returns Poll::Pending. Conversely, the runtime knows the future is ready and advances it when poll returns Poll::Ready(Some(message)) or Poll::Ready(None).": {
    "_translate": "在本章前面，我们描述了等待<code>rx.recv</code>。<code>recv</code>调用\n返回一个未来对象，等待该未来对象会轮询它。我们提到，当通道关闭时，运行时会\n暂停该未来对象，直到它准备好返回<code>Some(message)</code>或<code>None</code>。通过我们对<code>Future</code>特质的更深入理解，特别是<code>Future::poll</code>，我们可以看到它是如何工作的。当返回<code>Poll::Pending</code>时，运行时知道\n未来对象尚未准备好。相反，当<code>poll</code>返回\n<code>Poll::Ready(Some(message))</code>或<code>Poll::Ready(None)</code>时，运行时知道未来对象<em>已</em>准备好并推进它。",
    "_note": ""
  },
  "The Pin and Unpin Traits": {
    "_translate": "<a class=\"header\" href=\"#the-pin-and-unpin-traits\">《<code>Pin</code> 和 <code>Unpin</code> 特性》</a>",
    "_note": ""
  },
  "When we introduced the idea of pinning in Listing 17-16, we ran into a very gnarly error message. Here is the relevant part of it again:": {
    "_translate": "当我们介绍固定（pinning）的概念时，在清单 17-16 中遇到了一个非常棘手的错误信息。以下是相关部分：",
    "_note": ""
  },
  "This error message tells us not only that we need to pin the values but also why pinning is required. The trpl::join_all function returns a struct called JoinAll. That struct is generic over a type F, which is constrained to implement the Future trait. Directly awaiting a future with await pins the future implicitly. That’s why we don’t need to use pin! everywhere we want to await futures.": {
    "_translate": "这个错误信息不仅告诉我们需要固定这些值，还解释了为什么需要固定。`<code>trpl::join_all</code>` 函数返回一个名为 `<code>JoinAll</code>` 的结构体。该结构体泛型于类型 `<code>F</code>`，该类型被约束为实现 `<code>Future</code>` 特性。直接使用 `<code>await</code>` 等待一个未来会隐式地固定该未来。这就是为什么我们不需要在每个想要等待未来的代码中使用 `<code>pin!</code>`。",
    "_note": ""
  },
  "However, we’re not directly awaiting a future here. Instead, we construct a new future, JoinAll, by passing a collection of futures to the join_all function. The signature for join_all requires that the types of the items in the collection all implement the Future trait, and Box<T> implements Future only if the T it wraps is a future that implements the Unpin trait.": {
    "_translate": "然而，我们在这里并不是直接等待一个未来。相反，我们通过将一个未来集合传递给 <code>join_all</code> 函数来构建一个新的未来，<code>JoinAll</code>。<code>join_all</code> 的签名要求集合中的项目类型都实现 <code>Future</code> 特性，而 <code>Box&lt;T&gt;</code> 仅在其包装的 <code>T</code> 是一个实现了 <code>Unpin</code> 特性的未来时才实现 <code>Future</code>。",
    "_note": ""
  },
  "That’s a lot to absorb! To really understand it, let’s we dive a little further into how the Future trait actually works, in particular around pinning.": {
    "_translate": "这有很多需要吸收的内容！为了真正理解它，让我们进一步探讨 <code>Future</code> 特性实际上是如何工作的，特别是关于 <em>固定</em>。",
    "_note": ""
  },
  "Look again at the definition of the Future trait:": {
    "_translate": "再次查看 <code>Future</code> 特性的定义：",
    "_note": ""
  },
  "It tells Rust what type self must be for the method to be called.": {
    "_translate": "它告诉 Rust <code>self</code> 必须是什么类型才能调用该方法。",
    "_note": ""
  },
  "The cx parameter and its Context type are the key to how a runtime actually knows when to check any given future while still being lazy. Again, the details of how that works are beyond the scope of this chapter, and you generally only need to think about this when writing a custom Future implementation. We’ll focus instead on the type for self, as this is the first time we’ve seen a method where self has a type annotation. A type annotation for self is works like type annotations for other function parameters, but with two key differences:": {
    "_translate": "<code>cx</code> 参数及其 <code>Context</code> 类型是运行时实际上知道何时检查给定的未来同时仍然保持惰性化的关键。再次，这些工作原理的细节超出了本章的范围，通常只有在编写自定义 <code>Future</code> 实现时才需要考虑这一点。我们将重点放在 <code>self</code> 的类型上，因为这是第一次看到 <code>self</code> 有类型注解的方法。<code>self</code> 的类型注解与其他函数参数的类型注解类似，但有两个关键区别：",
    "_note": ""
  },
  "It can’t be just any type. It’s restricted to the type on which the method is implemented, a reference or smart pointer to that type, or a Pin wrapping a reference to that type.": {
    "_translate": "它不能是任意类型。它被限制为实现该方法的类型、该类型的引用或智能指针，或者是一个包裹该类型引用的<code>Pin</code>。",
    "_note": ""
  },
  "We’ll see more on this syntax in Chapter 18. For now, it’s enough to know that if we want to poll a future to check whether it is Pending or Ready(Output), we need a Pin-wrapped mutable reference to the type.": {
    "_translate": "我们将在<a href=\"ch18-00-oop.html\">第 18 章</a><!-- ignore -->中看到更多关于这种语法的内容。目前，\n知道如果我们想要轮询一个未来以检查它是<code>Pending</code>还是<code>Ready(Output)</code>，我们需要一个<code>Pin</code>包装的可变引用就足够了。",
    "_note": ""
  },
  "Pin is a wrapper for pointer-like types such as &, &mut, Box, and Rc. (Technically, Pin works with types that implement the Deref or DerefMut traits, but this is effectively equivalent to working only with pointers.) Pin is not a pointer itself and doesn’t have any behavior of its own like Rc and Arc do with reference counting; it’s purely a tool the compiler can use to enforce constraints on pointer usage.": {
    "_translate": "<code>Pin</code> 是一个包装器，用于像 <code>&amp;</code>、<code>&amp;mut</code>、<code>Box</code> 和 <code>Rc</code> 这样的指针类型。（技术上，<code>Pin</code> 适用于实现了 <code>Deref</code> 或 <code>DerefMut</code> 特性的类型，但这实际上等同于仅与指针一起工作。）<code>Pin</code> 本身不是一个指针，也没有像 <code>Rc</code> 和 <code>Arc</code> 那样具有引用计数的行为；它纯粹是编译器可以用来强制执行指针使用约束的工具。",
    "_note": ""
  },
  "Recalling that await is implemented in terms of calls to poll starts to explain the error message we saw earlier, but that was in terms of Unpin, not Pin. So how exactly does Pin relate to Unpin, and why does Future need self to be in a Pin type to call poll?": {
    "_translate": "回忆 <code>await</code> 是通过调用 <code>poll</code> 来实现的，这开始解释了我们之前看到的错误信息，但那是在 <code>Unpin</code> 的背景下，而不是 <code>Pin</code>。那么 <code>Pin</code> 到底是如何与 <code>Unpin</code> 相关的，为什么 <code>Future</code> 需要将 <code>self</code> 放在 <code>Pin</code> 类型中才能调用 <code>poll</code>？",
    "_note": ""
  },
  "Remember from earlier in this chapter a series of await points in a future get compiled into a state machine, and the compiler makes sure that state machine follows all of Rust’s normal rules around safety, including borrowing and ownership. To make that work, Rust looks at what data is needed between one await point and either the next await point or the end of the async block. It then creates a corresponding variant in the compiled state machine. Each variant gets the access it needs to the data that will be used in that section of the source code, whether by taking ownership of that data or by getting a mutable or immutable reference to it.": {
    "_translate": "记住本章前面提到的，在一个 future 中的一系列 await 点会被编译成一个状态机，编译器确保该状态机遵循 Rust 的所有正常安全规则，包括借用和所有权。为了使这一点生效，Rust 会查看从一个 await 点到下一个 await 点或 async 块结束之间需要哪些数据。然后在编译后的状态机中创建相应的变体。每个变体都会根据需要获取该部分源代码中将要使用的数据的访问权限，无论是通过获取该数据的所有权，还是通过获取其可变或不可变引用。",
    "_note": ""
  },
  "So far, so good: if we get anything wrong about the ownership or references in a given async block, the borrow checker will tell us. When we want to move around the future that corresponds to that block—like moving it into a Vec to pass to join_all—things get trickier.": {
    "_translate": "到目前为止，一切顺利：如果我们对给定异步块中的所有权或引用有任何错误，借用检查器会告诉我们。当我们想要移动与该块对应 的未来对象——比如将其移动到 <code>Vec</code> 中以传递给 <code>join_all</code>——事情就变得更复杂了。",
    "_note": ""
  },
  "When we move a future—whether by pushing it into a data structure to use as an iterator with join_all or by returning it from a function—that actually means moving the state machine Rust creates for us. And unlike most other types in Rust, the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant, as shown in the simplified illustration in Figure 17-4.": {
    "_translate": "当我们移动一个未来——无论是将其推入数据结构以用作 <code>join_all</code> 的迭代器，还是从函数返回它——这实际上意味着移动 Rust 为我们创建的状态机。与 Rust 中的大多数其他类型不同，Rust 为异步块创建的未来可以在任何给定变体的字段中最终包含对自身的引用，如图 17-4 中的简化图所示。",
    "_note": ""
  },
  "By default, though, any object that has a reference to itself is unsafe to move, because references always point to the actual memory address of whatever they refer to (see Figure 17-5). If you move the data structure itself, those internal references will be left pointing to the old location. However, that memory location is now invalid. For one thing, its value will not be updated when you make changes to the data structure. For another—more important—thing, the computer is now free to reuse that memory for other purposes! You could end up reading completely unrelated data later.": {
    "_translate": "默认情况下，任何具有指向自身引用的对象在移动时都是不安全的，因为引用总是指向它们所引用内容的实际内存地址（见图17-5）。如果你移动数据结构本身，这些内部引用将仍然指向旧位置。然而，该内存位置现在是无效的。一方面，当你对数据结构进行更改时，其值不会被更新。另一方面——更重要的是——计算机现在可以自由地将该内存用于其他目的！你可能会在稍后读取完全不相关的数据。",
    "_note": ""
  },
  "Theoretically, the Rust compiler could try to update every reference to an object whenever it gets moved, but that could add a lot of performance overhead, especially if a whole web of references needs updating. If we could instead make sure the data structure in question doesn’t move in memory, we wouldn’t have to update any references. This is exactly what Rust’s borrow checker requires: in safe code, it prevents you from moving any item with an active reference to it.": {
    "_translate": "理论上，Rust 编译器可以尝试在对象被移动时更新每个引用，但这可能会增加大量的性能开销，特别是当需要更新一整网的引用时。如果我们能够确保相关数据结构 <em>不会在内存中移动</em>，我们就不必更新任何引用。这正是 Rust 的借用检查器所要求的：在安全代码中，它会阻止你移动任何有活动引用的项。",
    "_note": ""
  },
  "Pin builds on that to give us the exact guarantee we need. When we pin a value by wrapping a pointer to that value in Pin, it can no longer move. Thus, if you have Pin<Box<SomeType>>, you actually pin the SomeType value, not the Box pointer. Figure 17-6 illustrates this process.": {
    "_translate": "<code>Pin</code> 建立在这一点上，为我们提供了所需的精确保证。当我们通过将指向该值的指针包装在 <code>Pin</code> 中来 <em>固定</em> 一个值时，该值将不能再移动。因此，如果你有 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>，你实际上固定的是 <code>SomeType</code> 值，<em>而不是</em> <code>Box</code> 指针。图 17-6 说明了这一过程。",
    "_note": ""
  },
  "In fact, the Box pointer can still move around freely. Remember: we care about making sure the data ultimately being referenced stays in place. If a pointer moves around, but the data it points to is in the same place, as in Figure 17-7, there’s no potential problem. As an independent exercise, look at the docs for the types as well as the std::pin module and try to work out how you’d do this with a Pin wrapping a Box.) The key is that the self-referential type itself cannot move, because it is still pinned.": {
    "_translate": "事实上，<code>Box</code> 指针仍然可以自由移动。记住：我们关心的是确保最终被引用的数据保持在原位。如果指针移动了，<em>但其所指向的数据仍在同一位置</em>，如图 17-7 所示，就没有潜在的问题。作为一个独立的练习，查看类型以及 <code>std::pin</code> 模块的文档，尝试弄清楚如何使用 <code>Pin</code> 包装一个 <code>Box</code>。) 关键在于，自引用类型本身不能移动，因为它仍然是固定的。",
    "_note": ""
  },
  "Unpin is a marker trait, similar to the Send and Sync traits we saw in Chapter 16, and thus has no functionality of its own. Marker traits exist only to tell the compiler it’s safe to use the type implementing a given trait in a particular context. Unpin informs the compiler that a given type does not need to uphold any guarantees about whether the value in question can be safely moved.": {
    "_translate": "<code>Unpin</code> 是一个标记特征，类似于我们在第 16 章中看到的 <code>Send</code> 和 <code>Sync</code> 特征，因此没有自己的功能。标记特征仅存在于告诉编译器在特定上下文中使用实现给定特征的类型是安全的。<code>Unpin</code> 告诉编译器给定类型<em>不需要</em>维持任何关于该值是否可以安全移动的保证。",
    "_note": ""
  },
  "However, most types are perfectly safe to move around, even if they happen to be behind a Pin pointer. We only need to think about pinning when items have internal references. Primitive values such as numbers and Booleans are safe since they obviously don’t have any internal references, so they’re obviously safe. Neither do most types you normally work with in Rust. You can move around a Vec, for example, without worrying. Given only what we have seen so far, if you have a Pin<Vec<String>>, you’d have to do everything via the safe but restrictive APIs provided by Pin, even though a Vec<String> is always safe to move if there are no other references to it. We need a way to tell the compiler that it’s fine to move items around in cases like this—and there’s where Unpin comes into play.": {
    "_translate": "然而，大多数类型即使在 <code>Pin</code> 指针后面也是完全安全的。只有当项目具有内部引用时，我们才需要考虑固定。像数字和布尔值这样的原始值显然是安全的，因为它们显然没有任何内部引用，所以它们显然是安全的。大多数你在 Rust 中通常使用的类型也是如此。例如，你可以随意移动一个 <code>Vec</code>，而无需担心。根据我们目前所见，如果你有一个 <code>Pin&lt;Vec&lt;String&gt;&gt;</code>，即使 <code>Vec&lt;String&gt;</code> 在没有其他引用的情况下总是可以安全移动，你也必须通过 <code>Pin</code> 提供的安全但限制性的 API 来做所有事情。我们需要一种方法来告诉编译器，在这种情况下移动项目是安全的——这就是 <code>Unpin</code> 发挥作用的地方。",
    "_note": ""
  },
  "In other words, there are two things to keep in mind about the relationship between Pin and Unpin. First, Unpin is the “normal” case, and !Unpin is the special case. Second, whether a type implements Unpin or !Unpin only matters when you’re using a pinned pointer to that type like Pin<&mut SomeType>.": {
    "_translate": "换句话说，关于 <code>Pin</code> 和 <code>Unpin</code> 之间的关系有两点需要注意。首先，<code>Unpin</code> 是“正常”情况，而 <code>!Unpin</code> 是特殊情况。其次，一个类型是否实现了 <code>Unpin</code> 或 <code>!Unpin</code> <em>仅在</em> 使用指向该类型的固定指针（如 <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>）时才重要。",
    "_note": ""
  },
  "Just as with Send and Sync, the compiler implements Unpin automatically for all types where it can prove it is safe. A special case, again similar to Send and Sync, is where Unpin is not implemented for a type. The notation for this is impl !Unpin for SomeType, where SomeType is the name of a type that does need to uphold those guarantees to be safe whenever a pointer to that type is used in a Pin.": {
    "_translate": "就像 <code>Send</code> 和 <code>Sync</code> 一样，编译器会自动为所有可以证明安全的类型实现 <code>Unpin</code>。一个特殊情况，再次类似于 <code>Send</code> 和 <code>Sync</code>，是 <code>Unpin</code> <em>没有</em> 为某个类型实现。这种表示方法是 <code>impl !Unpin for <em>SomeType</em></code>，其中 <code><em>SomeType</em></code> 是一个类型的名字，该类型在使用指向该类型的指针时 <em>确实</em> 需要保持这些保证以确保安全。",
    "_note": ""
  },
  "To make that concrete, think about a String: it has a length and the Unicode characters that make it up. We can wrap a String in Pin, as seen in Figure 17-8. However, String automatically implements Unpin, as do most other types in Rust.": {
    "_translate": "为了具体说明这一点，考虑一个 <code>String</code>：它有一个长度和组成它的 Unicode 字符。我们可以在 <code>Pin</code> 中包装一个 <code>String</code>，如图 17-8 所示。然而，<code>String</code> 自动实现了 <code>Unpin</code>，Rust 中的大多数其他类型也是如此。",
    "_note": ""
  },
  "As a result, we can do things that would be illegal if String implemented !Unpin instead, such as replacing one string with another at the exact same location in memory as in Figure 17-9. This doesn’t violate the Pin contract, because String has no internal references that make it unsafe to move around! That is precisely why it implements Unpin rather than !Unpin.": {
    "_translate": "因此，我们可以做一些如果 <code>String</code> 实现了 <code>!Unpin</code> 就会非法的事情，比如在内存中的确切相同位置用另一个字符串替换一个字符串，如图 17-9 所示。这不会违反 <code>Pin</code> 合约，因为 <code>String</code> 没有内部引用使其移动不安全！这正是它实现 <code>Unpin</code> 而不是 <code>!Unpin</code> 的原因。",
    "_note": ""
  },
  "Pin and Unpin are mostly important for building lower-level libraries, or when you’re building a runtime itself, rather than for day-to-day Rust code. When you see these traits in error messages, though, now you’ll have a better idea of how to fix your code!": {
    "_translate": "<code>Pin</code> 和 <code>Unpin</code> 主要对于构建底层库或构建运行时本身非常重要，而不是用于日常的 Rust 代码。当你在错误消息中看到这些特征时，现在你将更好地了解如何修复你的代码！",
    "_note": ""
  },
  "Note: This combination of Pin and Unpin makes it possible to safely implement a whole class of complex types in Rust that would otherwise prove challenging because they’re self-referential. Types that require Pin show up most commonly in async Rust today, but every once in a while, you might see them in other contexts, too.": {
    "_translate": "注意：这种 <code>Pin</code> 和 <code>Unpin</code> 的组合使得在 Rust 中安全实现一类复杂的类型成为可能，这些类型由于自引用而通常会变得具有挑战性。需要 <code>Pin</code> 的类型在今天的异步 Rust 中最为常见，但偶尔你也会在其他上下文中看到它们。",
    "_note": ""
  },
  "The specifics of how Pin and Unpin work, and the rules they’re required to uphold, are covered extensively in the API documentation for std::pin, so if you’re interested in learning more, that’s a great place to start.": {
    "_translate": "<code>Pin</code> 和 <code>Unpin</code> 的具体工作方式以及它们需要遵守的规则，在 <code>std::pin</code> 的 API 文档中有详细的介绍，所以如果你有兴趣深入了解，那是一个很好的起点。",
    "_note": ""
  },
  "If you want to understand how things work under the hood in even more detail, see Chapters 2 and 4 of Asynchronous Programming in Rust.": {
    "_translate": "如果你想更详细地了解底层的工作原理，请参阅<a href=\"https://rust-lang.github.io/async-book/02_execution/01_chapter.html\">第2章</a>和<a href=\"https://rust-lang.github.io/async-book/04_pinning/01_chapter.html\">第4章</a>的<a href=\"https://rust-lang.github.io/async-book/\"><em>Rust中的异步编程</em></a>。",
    "_note": ""
  },
  "Now that you have a deeper grasp on the Future, Pin, and Unpin traits, we can turn our attention to the Stream trait. As you learned earlier in the chapter, streams are similar to asynchronous iterators. Unlike Iterator and Future, however, Stream has no definition in the standard library as of this writing, but there is a very common definition from the futures crate used throughout the ecosystem.": {
    "_translate": "现在你对 <code>Future</code>、<code>Pin</code> 和 <code>Unpin</code> 特性有了更深的了解，我们可以将注意力转向 <code>Stream</code> 特性。正如你在本章前面所学，流类似于异步迭代器。然而，与 <code>Iterator</code> 和 <code>Future</code> 不同，<code>Stream</code> 在编写本文时标准库中没有定义，但 <code>futures</code> crate 中有一个非常常见的定义，被整个生态系统广泛使用。",
    "_note": ""
  },
  "The Stream trait defines an associated type called Item for the type of the items produced by the stream. This is similar to Iterator, where there may be zero to many items, and unlike Future, where there is always a single Output, even if it’s the unit type ().": {
    "_translate": "<code>Stream</code> 特性定义了一个关联类型 <code>Item</code>，用于表示流生成的项的类型。这类似于 <code>Iterator</code>，其中可能有零到多个项，而不像 <code>Future</code>，其中总是有一个单一的 <code>Output</code>，即使它是单元类型 <code>()</code>。",
    "_note": ""
  },
  "Let’s review the definitions of the Iterator and Future traits before looking at how a Stream trait might merge them together. From Iterator, we have the idea of a sequence: its next method provides an Option<Self::Item>. From Future, we have the idea of readiness over time: its poll method provides a Poll<Self::Output>. To represent a sequence of items that become ready over time, we define a Stream trait that puts those features together:": {
    "_translate": "让我们在查看 <code>Stream</code> 特性如何将它们合并之前，先回顾一下 <code>Iterator</code> 和 <code>Future</code> 特性的定义。从 <code>Iterator</code>，我们有序列的概念：其 <code>next</code> 方法提供一个 <code>Option&lt;Self::Item&gt;</code>。从 <code>Future</code>，我们有随时间变化的准备状态的概念：其 <code>poll</code> 方法提供一个 <code>Poll&lt;Self::Output&gt;</code>。为了表示随时间变得可用的项目序列，我们定义了一个 <code>Stream</code> 特性，将这些特性结合在一起：",
    "_note": ""
  },
  "Something very similar to this definition will likely end up as part of Rust’s standard library. In the meantime, it’s part of the toolkit of most runtimes, so you can rely on it, and everything we cover next should generally apply!": {
    "_translate": "与这个定义非常相似的内容很可能会成为 Rust 标准库的一部分。在此期间，它已经是大多数运行时工具包的一部分，因此你可以依赖它，接下来我们讨论的所有内容通常都适用！",
    "_note": ""
  },
  "Note: The actual definition we used earlier in the chapter looks slightly different than this, because it supports versions of Rust that did not yet support using async functions in traits. As a result, it looks like this:": {
    "_translate": "注意：本章前面实际使用的定义与此略有不同，因为它支持那些还不支持在特质中使用异步函数的 Rust 版本。因此，它看起来像这样：",
    "_note": ""
  },
  "In the example we saw in the section on streaming, though, we didn’t use poll_next or Stream, but instead used next and StreamExt. We could work directly in terms of the poll_next API by hand-writing our own Stream state machines, of course, just as we could work with futures directly via their poll method. Using await is much nicer, though, and the StreamExt trait supplies the next method so we can do just that:": {
    "_translate": "在我们之前在流处理部分看到的例子中，我们并没有使用 <code>poll_next</code> <em>或</em> <code>Stream</code>，而是使用了 <code>next</code> 和 <code>StreamExt</code>。我们当然<em>可以</em> 通过手动编写自己的 <code>Stream</code> 状态机来直接使用 <code>poll_next</code> API，就像我们<em>可以</em> 通过它们的 <code>poll</code> 方法直接处理未来对象一样。然而，使用 <code>await</code> 要方便得多，而 <code>StreamExt</code> 特性提供了 <code>next</code> 方法，使我们能够做到这一点：",
    "_note": ""
  },
  "That Next type is a struct that implements Future and allows us to name the lifetime of the reference to self with Next<'_, Self>, so that await can work with this method.": {
    "_translate": "那个 <code>Next</code> 类型是一个 <code>struct</code>，它实现了 <code>Future</code> 并允许我们用 <code>Next&lt;'_, Self&gt;</code> 命名对 <code>self</code> 的引用的生命周期，以便 <code>await</code> 可以与这个方法一起工作。",
    "_note": ""
  },
  "The StreamExt trait is also the home of all the interesting methods available to use with streams. StreamExt is automatically implemented for every type that implements Stream, but these traits are defined separately to enable the community to iterate on convenience APIs without affecting the foundational trait.": {
    "_translate": "<code>StreamExt</code> 特性也是所有可用于流的有趣方法的所在地。<code>StreamExt</code> 会自动为每个实现了 <code>Stream</code> 的类型实现，但这些特性是单独定义的，以便社区可以在不影响基础特性的情况下迭代便利的 API。",
    "_note": ""
  },
  "In the version of StreamExt used in the trpl crate, the trait not only defines the next method but also supplies a default implementation of next that correctly handles the details of calling Stream::poll_next. This means that even when you need to write your own streaming data type, you only have to implement Stream, and then anyone who uses your data type can use StreamExt and its methods with it automatically.": {
    "_translate": "在 <code>trpl</code> crate 中使用的 <code>StreamExt</code> 版本中，该 trait 不仅定义了 <code>next</code> 方法，还提供了一个默认的 <code>next</code> 实现，该实现正确处理了调用 <code>Stream::poll_next</code> 的细节。这意味着即使你需要编写自己的流数据类型，你也<em>只需</em>实现 <code>Stream</code>，然后任何使用你数据类型的人就可以自动使用 <code>StreamExt</code> 及其方法。",
    "_note": ""
  },
  "That’s a lot to absorb! To really understand it, let’s dive a little further into how the Future trait actually works, in particular around pinning.": {
    "_translate": "这有很多需要吸收的内容！为了真正理解它，让我们进一步探讨 <code>Future</code> 特性实际上是如何工作的，特别是关于 <em>固定</em>。",
    "_note": ""
  },
  "The cx parameter and its Context type are the key to how a runtime actually knows when to check any given future while still being lazy. Again, the details of how that works are beyond the scope of this chapter, and you generally only need to think about this when writing a custom Future implementation. We’ll focus instead on the type for self, as this is the first time we’ve seen a method where self has a type annotation. A type annotation for self works like type annotations for other function parameters, but with two key differences:": {
    "_translate": "<code>cx</code> 参数及其 <code>Context</code> 类型是运行时实际知道何时检查给定的未来同时仍然保持惰性化的关键。再次，这些工作原理的细节超出了本章的范围，通常只有在编写自定义 <code>Future</code> 实现时才需要考虑这一点。相反，我们将重点放在 <code>self</code> 的类型上，因为这是第一次看到 <code>self</code> 有类型注解的方法。<code>self</code> 的类型注解与其他函数参数的类型注解类似，但有两个关键区别：",
    "_note": ""
  },
  "However, most types are perfectly safe to move around, even if they happen to be behind a Pin wrapper. We only need to think about pinning when items have internal references. Primitive values such as numbers and Booleans obviously don’t have any internal references, so they’re safe. Neither do most types you normally work with in Rust. You can move around a Vec, for example, without worrying. Given only what we have seen so far, if you have a Pin<Vec<String>>, you’d have to do everything via the safe but restrictive APIs provided by Pin, even though a Vec<String> is always safe to move if there are no other references to it. We need a way to tell the compiler that it’s fine to move items around in cases like this—and there’s where Unpin comes into play.": {
    "_translate": "然而，大多数类型即使在 <code>Pin</code> 包装器后面也是完全安全的。只有当项目具有内部引用时，我们才需要考虑固定。显然，数字和布尔值等原始值没有任何内部引用，因此它们是安全的。大多数你在 Rust 中通常使用的类型也是如此。例如，你可以随意移动 <code>Vec</code>，而无需担心。根据我们迄今为止所见，如果你有一个 <code>Pin&lt;Vec&lt;String&gt;&gt;</code>，即使 <code>Vec&lt;String&gt;</code> 在没有其他引用的情况下总是可以安全移动的，你也必须通过 <code>Pin</code> 提供的安全但受限的 API 来完成所有操作。我们需要一种方法来告诉编译器，在这种情况下移动项目是安全的——这就是 <code>Unpin</code> 发挥作用的地方。",
    "_note": ""
  },
  "However, most types are perfectly safe to move around, even if they happen to be behind a Pin wrapper. We only need to think about pinning when items have internal references. Primitive values such as numbers and Booleans are safe because they obviously don’t have any internal references. Neither do most types you normally work with in Rust. You can move around a Vec, for example, without worrying. Given only what we have seen so far, if you have a Pin<Vec<String>>, you’d have to do everything via the safe but restrictive APIs provided by Pin, even though a Vec<String> is always safe to move if there are no other references to it. We need a way to tell the compiler that it’s fine to move items around in cases like this—and that’s where Unpin comes into play.": {
    "_translate": "【翻译引擎出错，请联系作者】",
    "_note": ""
  }
}