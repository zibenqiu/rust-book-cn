{
  "Turning Our Single-Threaded Server into a Multithreaded Server": {
    "_translate": "<a class=\"header\" href=\"#turning-our-single-threaded-server-into-a-multithreaded-server\">将我们的单线程服务器转换为多线程服务器</a>",
    "_note": ""
  },
  "Simulating a Slow Request in the Current Server Implementation": {
    "_translate": "<a class=\"header\" href=\"#simulating-a-slow-request-in-the-current-server-implementation\">在当前服务器实现中模拟慢请求</a>",
    "_note": ""
  },
  "Right now, the server will process each request in turn, meaning it won’t process a second connection until the first is finished processing. If the server received more and more requests, this serial execution would be less and less optimal. If the server receives a request that takes a long time to process, subsequent requests will have to wait until the long request is finished, even if the new requests can be processed quickly. We’ll need to fix this, but first, we’ll look at the problem in action.": {
    "_translate": "目前，服务器会依次处理每个请求，这意味着它不会在第一个请求处理完成之前处理第二个连接。如果服务器收到越来越多的请求，这种串行执行将变得越来越不高效。如果服务器收到一个需要长时间处理的请求，后续的请求将不得不等待，直到长时间的请求处理完成，即使新的请求可以快速处理。我们需要解决这个问题，但首先，我们将看看问题的实际表现。",
    "_note": ""
  },
  "We’ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 21-10 implements handling a request to /sleep with a simulated slow response that will cause the server to sleep for 5 seconds before responding.": {
    "_translate": "我们将研究一个处理缓慢的请求如何影响向我们当前服务器实现发出的其他请求。清单 21-10 实现了处理对 <em>/sleep</em> 的请求，该请求具有模拟的缓慢响应，将导致服务器在响应前休眠 5 秒。",
    "_note": ""
  },
  "We switched from if to match now that we have three cases. We need to explicitly match on a slice of request_line to pattern match against the string literal values; match doesn’t do automatic referencing and dereferencing like the equality method does.": {
    "_translate": "我们从 <code>if</code> 切换到 <code>match</code>，因为我们现在有三种情况。我们需要显式地匹配 <code>request_line</code> 的切片，以对字符串字面值进行模式匹配；<code>match</code> 不像等式方法那样自动引用和取消引用。",
    "_note": ""
  },
  "The first arm is the same as the if block from Listing 21-9. The second arm matches a request to /sleep. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page. The third arm is the same as the else block from Listing 21-9.": {
    "_translate": "第一个分支与列表 21-9 中的 <code>if</code> 块相同。第二个分支\n匹配对 <em>/sleep</em> 的请求。当收到该请求时，服务器将在呈现成功的 HTML 页面之前\n休眠 5 秒。第三个分支与列表 21-9 中的 <code>else</code> 块相同。",
    "_note": ""
  },
  "You can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!": {
    "_translate": "你可以看到我们的服务器是多么原始：真正的库会以一种简洁得多的方式处理多个请求的识别！",
    "_note": ""
  },
  "There are multiple techniques we could use to avoid requests backing up behind a slow request, including using async as we did Chapter 17; the one we’ll implement is a thread pool.": {
    "_translate": "我们可以使用多种技术来避免请求在慢请求后面堆积，包括在第 17 章中使用的方法异步；我们将要实现的是线程池。",
    "_note": ""
  },
  "Improving Throughput with a Thread Pool": {
    "_translate": "<a class=\"header\" href=\"#improving-throughput-with-a-thread-pool\">使用线程池提高吞吐量</a>",
    "_note": ""
  },
  "Start the server using cargo run. Then open two browser windows: one for http://127.0.0.1:7878/ and the other for http://127.0.0.1:7878/sleep. If you enter the / URI a few times, as before, you’ll see it respond quickly. But if you enter /sleep and then load /, you’ll see that / waits until sleep has slept for its full 5 seconds before loading.": {
    "_translate": "使用 <code>cargo run</code> 启动服务器。然后打开两个浏览器窗口：一个用于 <em>http://127.0.0.1:7878/</em>，另一个用于 <em>http://127.0.0.1:7878/sleep</em>。如果你多次输入 <em>/</em> URI，就像之前一样，你会看到它响应很快。但如果你输入 <em>/sleep</em> 然后加载 <em>/</em>，你会看到 <em>/</em> 会等待 <code>sleep</code> 完成其完整的 5 秒后才加载。",
    "_note": ""
  },
  "We’ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server’s resources and grinding the processing of requests to a halt.": {
    "_translate": "我们将线程池中的线程数量限制为一个小数目，以保护我们免受拒绝服务（DoS）攻击；如果我们为每个传入的请求创建一个新线程，那么有人对我们服务器发起1000万个请求就可能会耗尽我们服务器的所有资源，导致请求处理停滞。",
    "_note": ""
  },
  "A thread pool is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it’s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.": {
    "_translate": "一个<em>线程池</em>是一组已创建的线程，它们在等待并准备好处理任务。当程序接收到新任务时，它会将线程池中的一个线程分配给该任务，该线程将处理任务。线程池中剩余的线程可用于处理在第一个线程处理期间到来的任何其他任务。当第一个线程完成其任务处理后，它会被返回到空闲线程池中，准备处理新任务。线程池允许你并发处理连接，提高服务器的吞吐量。",
    "_note": ""
  },
  "This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model, the single-threaded async I/O model, or the multi-threaded async I/O model. If you’re interested in this topic, you can read more about other solutions and try to implement them; with a low-level language like Rust, all of these options are possible.": {
    "_translate": "这种技术只是提高Web服务器吞吐量的众多方法之一。其他你可以探索的选项包括<em>fork/join模型</em>、<em>单线程异步I/O模型</em>或<em>多线程异步I/O模型</em>。如果你对这个话题感兴趣，可以阅读更多关于其他解决方案的信息并尝试实现它们；使用像Rust这样的低级语言，所有这些选项都是可能的。",
    "_note": ""
  },
  "Rather than spawning unlimited threads, then, we’ll have a fixed number of threads waiting in the pool. Requests that come in are sent to the pool for processing. The pool will maintain a queue of incoming requests. Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request. With this design, we can process up to N requests concurrently, where N is the number of threads. If each thread is responding to a long-running request, subsequent requests can still back up in the queue, but we’ve increased the number of long-running requests we can handle before reaching that point.": {
    "_translate": "而不是生成无限的线程，我们将有一个固定数量的线程在池中等待。进入的请求将被发送到池中进行处理。池将维护一个传入请求的队列。池中的每个线程将从这个队列中弹出一个请求，处理该请求，然后向队列请求另一个请求。通过这种设计，我们可以同时处理多达 <code>N</code> 个请求，其中 <code>N</code> 是线程的数量。如果每个线程都在响应一个长时间运行的请求，后续的请求仍然可以在队列中积压，但我们已经增加了在达到这一点之前可以处理的长时间运行请求的数量。",
    "_note": ""
  },
  "Before we begin implementing a thread pool, let’s talk about what using the pool should look like. When you’re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it’s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.": {
    "_translate": "在我们开始实现线程池之前，让我们先谈谈使用线程池应该是什么样子。当你试图设计代码时，先编写客户端接口可以帮助指导你的设计。编写代码的API，使其结构符合你希望调用的方式；然后在该结构内实现功能，而不是先实现功能再设计公共API。",
    "_note": ""
  },
  "Similar to how we used test-driven development in the project in Chapter 12, we’ll use compiler-driven development here. We’ll write the code that calls the functions we want, and then we’ll look at errors from the compiler to determine what we should change next to get the code to work. Before we do that, however, we’ll explore the technique we’re not going to use as a starting point.": {
    "_translate": "类似于我们在第12章的项目中使用测试驱动开发的方式，我们将在这里使用编译器驱动开发。我们将编写调用我们想要的函数的代码，然后查看编译器的错误以确定我们应该做哪些更改使代码正常工作。不过，在此之前，我们将探讨我们不会使用的技术作为起点。",
    "_note": ""
  },
  "First, let’s explore how our code might look if it did create a new thread for every connection. As mentioned earlier, this isn’t our final plan due to the problems with potentially spawning an unlimited number of threads, but it is a starting point to get a working multithreaded server first. Then we’ll add the thread pool as an improvement, and contrasting the two solutions will be easier. Listing 21-11 shows the changes to make to main to spawn a new thread to handle each stream within the for loop.": {
    "_translate": "首先，让我们看看如果为每个连接创建一个新线程，代码可能会是什么样子。如前所述，这不是我们的最终计划，因为可能会产生无限数量的线程，但这是一个起点，首先实现一个多线程服务器。然后我们将添加线程池作为改进，对比两种解决方案将更容易。清单 21-11 显示了对 <code>main</code> 的更改，以在 <code>for</code> 循环中为每个流生成一个新线程。",
    "_note": ""
  },
  "You may also recall from Chapter 17 that this is exactly the kind of situation where async and await really shine! Keep that in mind as we build the thread pool and think about how things would look different or the same with async.": {
    "_translate": "您可能还记得第 17 章中提到的，这正是 async 和 await 大放异彩的情况！在我们构建线程池时，请记住这一点，并思考如果使用 async 事情会有什么不同或相同。",
    "_note": ""
  },
  "We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn’t require large changes to the code that uses our API. Listing 21-12 shows the hypothetical interface for a ThreadPool struct we want to use instead of thread::spawn.": {
    "_translate": "我们希望我们的线程池以类似且熟悉的方式工作，以便从线程切换到线程池时，不需要对使用我们API的代码进行大的更改。清单21-12展示了我们希望使用的<code>ThreadPool</code>结构体的假设接口，用以替代<code>thread::spawn</code>。",
    "_note": ""
  },
  "As you learned in Chapter 16, thread::spawn will create a new thread and then run the code in the closure in the new thread. If you run this code and load /sleep in your browser, then / in two more browser tabs, you’ll indeed see that the requests to / don’t have to wait for /sleep to finish. However, as we mentioned, this will eventually overwhelm the system because you’d be making new threads without any limit.": {
    "_translate": "正如你在第 16 章中学到的，<code>thread::spawn</code> 将创建一个新线程，然后在新线程中运行闭包中的代码。如果你运行此代码并在浏览器中加载 <em>/sleep</em>，然后在另外两个浏览器标签中加载 <em>/</em>，你确实会看到对 <em>/</em> 的请求不必等待 <em>/sleep</em> 完成。然而，正如我们提到的，这最终会压垮系统，因为你将无限制地创建新线程。",
    "_note": ""
  },
  "Make the changes in Listing 21-12 to src/main.rs, and then let’s use the compiler errors from cargo check to drive our development. Here is the first error we get:": {
    "_translate": "在清单 21-12 中对 <em>src/main.rs</em> 做出更改，然后让我们使用 <code>cargo check</code> 的编译错误来驱动我们的开发。这是我们得到的第一个错误：",
    "_note": ""
  },
  "We use ThreadPool::new to create a new thread pool with a configurable number of threads, in this case four. Then, in the for loop, pool.execute has a similar interface as thread::spawn in that it takes a closure the pool should run for each stream. We need to implement pool.execute so it takes the closure and gives it to a thread in the pool to run. This code won’t yet compile, but we’ll try so the compiler can guide us in how to fix it.": {
    "_translate": "我们使用<code>ThreadPool::new</code>来创建一个具有可配置线程数的新线程池，在这种情况下是四个。然后，在<code>for</code>循环中，<code>pool.execute</code>的接口与<code>thread::spawn</code>类似，因为它接受一个闭包，池中的每个流都应该运行这个闭包。我们需要实现<code>pool.execute</code>，以便它接受闭包并将其交给池中的一个线程来运行。这段代码还不能编译，但我们会尝试编译，以便编译器可以指导我们如何修复它。",
    "_note": ""
  },
  "Create a src/lib.rs that contains the following, which is the simplest definition of a ThreadPool struct that we can have for now:": {
    "_translate": "创建一个 <em>src/lib.rs</em>，其中包含以下内容，这是我们目前可以拥有的最简单的 <code>ThreadPool</code> 结构体定义：",
    "_note": ""
  },
  "Then edit main.rs file to bring ThreadPool into scope from the library crate by adding the following code to the top of src/main.rs:": {
    "_translate": "然后编辑 <em>main.rs</em> 文件，通过在 <em>src/main.rs</em> 的顶部添加以下代码将 <code>ThreadPool</code> 从库 crate 引入作用域：",
    "_note": ""
  },
  "Great! This error tells us we need a ThreadPool type or module, so we’ll build one now. Our ThreadPool implementation will be independent of the kind of work our web server is doing. So, let’s switch the hello crate from a binary crate to a library crate to hold our ThreadPool implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.": {
    "_translate": "很好！这个错误告诉我们需要一个<code>ThreadPool</code>类型或模块，所以我们现在就来构建一个。我们的<code>ThreadPool</code>实现将独立于我们的Web服务器正在执行的工作类型。因此，让我们将<code>hello</code> crate从一个二进制crate转换为一个库crate来保存我们的<code>ThreadPool</code>实现。在转换为库crate之后，我们还可以使用单独的线程池库来执行我们想要使用线程池的任何工作，而不仅仅是处理Web请求。",
    "_note": ""
  },
  "This code still won’t work, but let’s check it again to get the next error that we need to address:": {
    "_translate": "这段代码仍然无法工作，但让我们再次检查它以获取需要解决的下一个错误：",
    "_note": ""
  },
  "We chose usize as the type of the size parameter, because we know that a negative number of threads doesn’t make any sense. We also know we’ll use this 4 as the number of elements in a collection of threads, which is what the usize type is for, as discussed in the “Integer Types” section of Chapter 3.": {
    "_translate": "我们选择<code>usize</code>作为<code>size</code>参数的类型，因为我们知道负数的线程数量是没有意义的。我们还知道我们将使用这个4作为线程集合中元素的数量，这就是<code>usize</code>类型的用途，如在第3章的<a href=\"ch03-02-data-types.html#integer-types\">“整数类型”</a><!--\nignore -->部分所讨论的。",
    "_note": ""
  },
  "This error indicates that next we need to create an associated function named new for ThreadPool. We also know that new needs to have one parameter that can accept 4 as an argument and should return a ThreadPool instance. Let’s implement the simplest new function that will have those characteristics:": {
    "_translate": "这个错误表明接下来我们需要为 <code>ThreadPool</code> 创建一个名为 <code>new</code> 的关联函数。我们还知道 <code>new</code> 需要有一个参数，可以接受 <code>4</code> 作为参数，并且应该返回一个 <code>ThreadPool</code> 实例。让我们实现一个最简单的 <code>new</code> 函数，它将具有这些特征：",
    "_note": ""
  },
  "Let’s check the code again:": {
    "_translate": "让我们再次检查代码：",
    "_note": ""
  },
  "Now the error occurs because we don’t have an execute method on ThreadPool. Recall from the “Creating a Finite Number of Threads” section that we decided our thread pool should have an interface similar to thread::spawn. In addition, we’ll implement the execute function so it takes the closure it’s given and gives it to an idle thread in the pool to run.": {
    "_translate": "现在错误发生是因为我们在 <code>ThreadPool</code> 上没有 <code>execute</code> 方法。\n回想 <a href=\"#creating-a-finite-number-of-threads\">“创建有限数量的线程”</a><!-- ignore --> 部分，我们\n决定我们的线程池应该有一个类似于 <code>thread::spawn</code> 的接口。此外，我们将实现 <code>execute</code> 函数，使其接收给定的闭包并将其交给池中的空闲线程来运行。",
    "_note": ""
  },
  "We’ll define the execute method on ThreadPool to take a closure as a parameter. Recall from the “Moving Captured Values Out of the Closure and the Fn Traits” section in Chapter 13 that we can take closures as parameters with three different traits: Fn, FnMut, and FnOnce. We need to decide which kind of closure to use here. We know we’ll end up doing something similar to the standard library thread::spawn implementation, so we can look at what bounds the signature of thread::spawn has on its parameter. The documentation shows us the following:": {
    "_translate": "我们将为 <code>ThreadPool</code> 定义 <code>execute</code> 方法，以闭包作为参数。回想第 13 章的 <a href=\"ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits\">“将捕获的值移出闭包和 <code>Fn</code> 特性”</a><!-- ignore --> 部分，我们可以使用三种不同的特性来接受闭包作为参数：<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>。我们需要决定在这里使用哪种闭包。我们知道最终会做类似于标准库 <code>thread::spawn</code> 实现的事情，因此可以查看 <code>thread::spawn</code> 的参数签名有哪些约束。文档显示如下：",
    "_note": ""
  },
  "The F type parameter also has the trait bound Send and the lifetime bound 'static, which are useful in our situation: we need Send to transfer the closure from one thread to another and 'static because we don’t know how long the thread will take to execute. Let’s create an execute method on ThreadPool that will take a generic parameter of type F with these bounds:": {
    "_translate": "<code>F</code> 类型参数也有 <code>Send</code> 特性边界和 <code>'static</code> 生命周期边界，这些在我们的情况下非常有用：我们需要 <code>Send</code> 来将闭包从一个线程传递到另一个线程，以及 <code>'static</code> 是因为我们不知道线程执行需要多长时间。让我们在 <code>ThreadPool</code> 上创建一个 <code>execute</code> 方法，该方法将接受一个具有这些边界泛型参数 <code>F</code>：",
    "_note": ""
  },
  "The F type parameter is the one we’re concerned with here; the T type parameter is related to the return value, and we’re not concerned with that. We can see that spawn uses FnOnce as the trait bound on F. This is probably what we want as well, because we’ll eventually pass the argument we get in execute to spawn. We can be further confident that FnOnce is the trait we want to use because the thread for running a request will only execute that request’s closure one time, which matches the Once in FnOnce.": {
    "_translate": "<code>F</code> 类型参数是我们这里关注的；<code>T</code> 类型参数与返回值相关，我们不关心这个。我们可以看到 <code>spawn</code> 使用 <code>FnOnce</code> 作为 <code>F</code> 的特征约束。这可能也是我们想要的，因为最终我们会将 <code>execute</code> 中接收到的参数传递给 <code>spawn</code>。我们可以更加确信 <code>FnOnce</code> 是我们想要使用的特征，因为运行请求的线程只会执行该请求的闭包一次，这与 <code>FnOnce</code> 中的 <code>Once</code> 相符。",
    "_note": ""
  },
  "Again, this is the simplest implementation of the execute method: it does nothing, but we’re trying only to make our code compile. Let’s check it again:": {
    "_translate": "再次，这是 <code>execute</code> 方法的最简单实现：它什么也不做，但我们只是试图让我们的代码编译。让我们再次检查它：",
    "_note": ""
  },
  "We still use the () after FnOnce because this FnOnce represents a closure that takes no parameters and returns the unit type (). Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.": {
    "_translate": "我们仍然在 <code>FnOnce</code> 后使用 <code>()</code>，因为这个 <code>FnOnce</code> 表示一个不接受任何参数并返回单元类型 <code>()</code> 的闭包。就像函数定义一样，返回类型可以从签名中省略，但即使我们没有参数，仍然需要括号。",
    "_note": ""
  },
  "It compiles! But note that if you try cargo run and make a request in the browser, you’ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn’t actually calling the closure passed to execute yet!": {
    "_translate": "它编译了！但请注意，如果您尝试<code>cargo run</code>并在浏览器中发出请求，您会看到我们在本章开头看到的错误。我们的库实际上还没有调用传递给<code>execute</code>的闭包！",
    "_note": ""
  },
  "Consider: what would be different here if we were going to execute a future instead of a closure?": {
    "_translate": "考虑：如果我们执行的是一个<em>future</em>而不是闭包，这里会有哪些不同？",
    "_note": ""
  },
  "Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is “if the code compiles, it works.” But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles and has the behavior we want.": {
    "_translate": "注意：你可能会听到关于像 Haskell 和 Rust 这样具有严格编译器的语言的说法是，“如果代码编译，它就能工作。” 但这句话并不普遍正确。我们的项目编译了，但它什么也不做！如果我们正在构建一个真实、完整的项目，现在是开始编写单元测试以检查代码是否编译 <em>并且</em> 具有我们想要的行为的好时机。",
    "_note": ""
  },
  "We aren’t doing anything with the parameters to new and execute. Let’s implement the bodies of these functions with the behavior we want. To start, let’s think about new. Earlier we chose an unsigned type for the size parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid usize. We’ll add code to check that size is greater than zero before we return a ThreadPool instance and have the program panic if it receives a zero by using the assert! macro, as shown in Listing 21-13.": {
    "_translate": "我们没有对 <code>new</code> 和 <code>execute</code> 的参数做任何处理。让我们实现这些函数的主体，以实现我们想要的行为。首先，让我们思考 <code>new</code>。早些时候，我们为 <code>size</code> 参数选择了一个无符号类型，因为拥有负数个线程的池是没有意义的。然而，拥有零个线程的池也没有意义，但零是一个完全有效的 <code>usize</code>。我们将在返回 <code>ThreadPool</code> 实例之前添加代码来检查 <code>size</code> 是否大于零，并使用 <code>assert!</code> 宏在接收到零时使程序崩溃，如清单 21-13 所示。",
    "_note": ""
  },
  "We’ve also added some documentation for our ThreadPool with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running cargo doc --open and clicking the ThreadPool struct to see what the generated docs for new look like!": {
    "_translate": "我们还为我们的<code>ThreadPool</code> 添加了一些文档，使用了文档注释。\n请注意，我们遵循了良好的文档实践，添加了一个部分，指出了我们的函数可能 panic 的情况，正如在第 14 章中讨论的那样。\n尝试运行 <code>cargo doc --open</code> 并点击 <code>ThreadPool</code> 结构体，看看生成的 <code>new</code> 方法的文档是什么样的！",
    "_note": ""
  },
  "Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the ThreadPool struct before returning the struct. But how do we “store” a thread? Let’s take another look at the thread::spawn signature:": {
    "_translate": "现在我们有了一个方法来确定存储在池中的线程数量是有效的，我们可以在返回结构体之前创建这些线程并将它们存储在<code>ThreadPool</code>结构体中。但是我们如何“存储”一个线程？让我们再来看看<code>thread::spawn</code>的签名：",
    "_note": ""
  },
  "The spawn function returns a JoinHandle<T>, where T is the type that the closure returns. Let’s try using JoinHandle too and see what happens. In our case, the closures we’re passing to the thread pool will handle the connection and not return anything, so T will be the unit type ().": {
    "_translate": "<code>spawn</code> 函数返回一个 <code>JoinHandle&lt;T&gt;</code>，其中 <code>T</code> 是闭包返回的类型。让我们也尝试使用 <code>JoinHandle</code> 并看看会发生什么。在我们的情况下，传递给线程池的闭包将处理连接并且不返回任何内容，因此 <code>T</code> 将是单元类型 <code>()</code>。",
    "_note": ""
  },
  "Instead of adding the assert! macro as we’ve done here, we could change new into build and return a Result like we did with Config::build in the I/O project in Listing 12-9. But we’ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you’re feeling ambitious, try to write a function named build with the following signature to compare with the new function:": {
    "_translate": "而不是像这里所做的那样添加 <code>assert!</code> 宏，我们可以将 <code>new</code> 改为 <code>build</code> 并返回一个 <code>Result</code>，就像我们在列表 12-9 的 I/O 项目中对 <code>Config::build</code> 所做的那样。但在这种情况下，我们决定尝试创建一个没有任何线程的线程池应该是一个不可恢复的错误。如果你雄心勃勃，试着编写一个名为 <code>build</code> 的函数，其签名如下，以便与 <code>new</code> 函数进行比较：",
    "_note": ""
  },
  "We’ve brought std::thread into scope in the library crate, because we’re using thread::JoinHandle as the type of the items in the vector in ThreadPool.": {
    "_translate": "我们已经将<code>std::thread</code>引入到库crate中，因为我们正在使用<code>thread::JoinHandle</code>作为<code>ThreadPool</code>中向量项的类型。",
    "_note": ""
  },
  "The code in Listing 21-14 will compile but doesn’t create any threads yet. We’ve changed the definition of ThreadPool to hold a vector of thread::JoinHandle<()> instances, initialized the vector with a capacity of size, set up a for loop that will run some code to create the threads, and returned a ThreadPool instance containing them.": {
    "_translate": "列表 21-14 中的代码可以编译，但还没有创建任何线程。\n我们已经将 <code>ThreadPool</code> 的定义更改为持有 <code>thread::JoinHandle&lt;()&gt;</code> 实例的向量，用 <code>size</code> 初始化了向量的容量，设置了一个 <code>for</code> 循环来运行一些创建线程的代码，并返回了一个包含这些线程的 <code>ThreadPool</code> 实例。",
    "_note": ""
  },
  "When you run cargo check again, it should succeed.": {
    "_translate": "当你再次运行 <code>cargo check</code> 时，它应该成功。",
    "_note": ""
  },
  "We left a comment in the for loop in Listing 21-14 regarding the creation of threads. Here, we’ll look at how we actually create threads. The standard library provides thread::spawn as a way to create threads, and thread::spawn expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them wait for code that we’ll send later. The standard library’s implementation of threads doesn’t include any way to do that; we have to implement it manually.": {
    "_translate": "我们在清单 21-14 的 <code>for</code> 循环中留下了一个关于创建线程的注释。在这里，我们将看看我们实际上是如何创建线程的。标准库提供了 <code>thread::spawn</code> 作为创建线程的一种方式，<code>thread::spawn</code> 期望在创建线程时立即运行的代码。然而，在我们的情况下，我们希望创建线程并让它们 <em>等待</em> 我们稍后发送的代码。标准库的线程实现不包括任何实现这一点的方法；我们必须手动实现它。",
    "_note": ""
  },
  "Once a valid size is received, our ThreadPool creates a new vector that can hold size items. The with_capacity function performs the same task as Vec::new but with an important difference: it preallocates space in the vector. Because we know we need to store size elements in the vector, doing this allocation up front is slightly more efficient than using Vec::new, which resizes itself as elements are inserted.": {
    "_translate": "一旦收到有效的大小，我们的<code>ThreadPool</code>将创建一个可以容纳<code>size</code>个项目的向量。<code>with_capacity</code>函数执行与<code>Vec::new</code>相同的任务，但有一个重要的区别：它预先分配向量中的空间。因为我们知道需要在向量中存储<code>size</code>个元素，所以预先进行这种分配比使用<code>Vec::new</code>稍微更有效，后者在插入元素时会自行调整大小。",
    "_note": ""
  },
  "We’ll implement this behavior by introducing a new data structure between the ThreadPool and the threads that will manage this new behavior. We’ll call this data structure Worker, which is a common term in pooling implementations. The Worker picks up code that needs to be run and runs the code in the Worker’s thread. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they’re responsible for taking those orders and fulfilling them.": {
    "_translate": "我们将通过在<code>ThreadPool</code>和线程之间引入一个新的数据结构来实现这种行为，这个数据结构将管理这种新行为。我们将这个数据结构称为<em>Worker</em>，这是池化实现中常用的一个术语。Worker会拾取需要运行的代码，并在Worker的线程中运行这些代码。想象一下餐厅厨房里的工作人员：工作人员会等待顾客的订单到来，然后他们负责接收这些订单并完成它们。",
    "_note": ""
  },
  "Instead of storing a vector of JoinHandle<()> instances in the thread pool, we’ll store instances of the Worker struct. Each Worker will store a single JoinHandle<()> instance. Then we’ll implement a method on Worker that will take a closure of code to run and send it to the already running thread for execution. We’ll also give each worker an id so we can distinguish between the different workers in the pool when logging or debugging.": {
    "_translate": "而不是在线程池中存储 <code>JoinHandle&lt;()&gt;</code> 实例的向量，我们将存储 <code>Worker</code> 结构的实例。每个 <code>Worker</code> 将存储一个 <code>JoinHandle&lt;()&gt;</code> 实例。然后我们将在 <code>Worker</code> 上实现一个方法，该方法将接受一个要运行的闭包代码，并将其发送到已经运行的线程中执行。我们还将给每个工作线程一个 <code>id</code>，以便在日志记录或调试时区分池中的不同工作线程。",
    "_note": ""
  },
  "Here is the new process that will happen when we create a ThreadPool. We’ll implement the code that sends the closure to the thread after we have Worker set up in this way:": {
    "_translate": "这是我们将要在创建<code>ThreadPool</code>时发生的新流程。我们将在<code>Worker</code>以这种方式设置好之后，实现将闭包发送到线程的代码。",
    "_note": ""
  },
  "If you’re up for a challenge, try implementing these changes on your own before looking at the code in Listing 21-15.": {
    "_translate": "如果您喜欢挑战，可以尝试在查看清单 21-15 中的代码之前自己实现这些更改。",
    "_note": ""
  },
  "Ready? Here is Listing 21-15 with one way to make the preceding modifications.": {
    "_translate": "准备好？以下是带有其中一种方法的清单 21-15，用于进行上述修改。",
    "_note": ""
  },
  "We’ve changed the name of the field on ThreadPool from threads to workers because it’s now holding Worker instances instead of JoinHandle<()> instances. We use the counter in the for loop as an argument to Worker::new, and we store each new Worker in the vector named workers.": {
    "_translate": "我们将 <code>ThreadPool</code> 上的字段名从 <code>threads</code> 更改为 <code>workers</code>，因为现在它保存的是 <code>Worker</code> 实例而不是 <code>JoinHandle&lt;()&gt;</code> 实例。我们在 <code>for</code> 循环中使用计数器作为 <code>Worker::new</code> 的参数，并将每个新的 <code>Worker</code> 存储在名为 <code>workers</code> 的向量中。",
    "_note": ""
  },
  "External code (like our server in src/main.rs) doesn’t need to know the implementation details regarding using a Worker struct within ThreadPool, so we make the Worker struct and its new function private. The Worker::new function uses the id we give it and stores a JoinHandle<()> instance that is created by spawning a new thread using an empty closure.": {
    "_translate": "外部代码（如 <em>src/main.rs</em> 中的服务器）不需要知道在 <code>ThreadPool</code> 内部使用 <code>Worker</code> 结构体的实现细节，因此我们将 <code>Worker</code> 结构体及其 <code>new</code> 函数设为私有。<code>Worker::new</code> 函数使用我们提供的 <code>id</code>，并存储一个通过使用空闭包创建的新线程生成的 <code>JoinHandle&lt;()&gt;</code> 实例。",
    "_note": ""
  },
  "This code will compile and will store the number of Worker instances we specified as an argument to ThreadPool::new. But we’re still not processing the closure that we get in execute. Let’s look at how to do that next.": {
    "_translate": "这段代码将编译，并将我们作为 <code>ThreadPool::new</code> 的参数指定的 <code>Worker</code> 实例的数量存储起来。但我们 <em>仍然</em> 没有处理我们在 <code>execute</code> 中接收到的闭包。接下来让我们看看如何处理这个问题。",
    "_note": ""
  },
  "Note: If the operating system can’t create a thread because there aren’t enough system resources, thread::spawn will panic. That will cause our whole server to panic, even though the creation of some threads might succeed. For simplicity’s sake, this behavior is fine, but in a production thread pool implementation, you’d likely want to use std::thread::Builder and its spawn method that returns Result instead.": {
    "_translate": "注意：如果操作系统因为系统资源不足而无法创建线程，<code>thread::spawn</code> 将会 panic。这将导致我们的整个服务器 panic，即使某些线程的创建可能成功。为了简单起见，这种行为是可以接受的，但在生产环境的线程池实现中，你可能希望使用 <a href=\"../std/thread/struct.Builder.html\"><code>std::thread::Builder</code></a><!-- ignore --> 及其 <a href=\"../std/thread/struct.Builder.html#method.spawn\"><code>spawn</code></a><!-- ignore --> 方法，该方法返回 <code>Result</code>。",
    "_note": ""
  },
  "We want the Worker structs that we just created to fetch the code to run from a queue held in the ThreadPool and send that code to its thread to run.": {
    "_translate": "我们希望我们刚刚创建的<code>Worker</code>结构体能够从<code>ThreadPool</code>中持有的队列中获取要运行的代码，并将该代码发送到其线程以运行。",
    "_note": ""
  },
  "The next problem we’ll tackle is that the closures given to thread::spawn do absolutely nothing. Currently, we get the closure we want to execute in the execute method. But we need to give thread::spawn a closure to run when we create each Worker during the creation of the ThreadPool.": {
    "_translate": "我们接下来要解决的问题是，传递给<code>thread::spawn</code>的闭包什么也不做。目前，我们在<code>execute</code>方法中获取要执行的闭包。但是我们需要在创建<code>ThreadPool</code>时，为每个<code>Worker</code>的创建提供一个闭包，让<code>thread::spawn</code>运行。",
    "_note": ""
  },
  "The channels we learned about in Chapter 16—a simple way to communicate between two threads—would be perfect for this use case. We’ll use a channel to function as the queue of jobs, and execute will send a job from the ThreadPool to the Worker instances, which will send the job to its thread. Here is the plan:": {
    "_translate": "我们在第16章中学到的通道——一种在两个线程之间进行简单通信的方式——非常适合这种情况。我们将使用一个通道作为作业队列，<code>execute</code> 将从 <code>ThreadPool</code> 向 <code>Worker</code> 实例发送作业，后者将作业发送到其线程。以下是计划：",
    "_note": ""
  },
  "In ThreadPool::new, we create our new channel and have the pool hold the sender. This will successfully compile.": {
    "_translate": "在 <code>ThreadPool::new</code> 中，我们创建了新的通道，并让线程池持有发送者。这将成功编译。",
    "_note": ""
  },
  "Let’s start by creating a channel in ThreadPool::new and holding the sender in the ThreadPool instance, as shown in Listing 21-16. The Job struct doesn’t hold anything for now but will be the type of item we’re sending down the channel.": {
    "_translate": "让我们先在 <code>ThreadPool::new</code> 中创建一个通道，并在 <code>ThreadPool</code> 实例中持有发送者，如清单 21-16 所示。<code>Job</code> 结构体目前不持有任何内容，但将是我们在通道中发送的项的类型。",
    "_note": ""
  },
  "We’ve made some small and straightforward changes: we pass the receiver into Worker::new, and then we use it inside the closure.": {
    "_translate": "我们做了一些小而简单的更改：我们将接收者传递给<code>Worker::new</code>，然后在闭包中使用它。",
    "_note": ""
  },
  "When we try to check this code, we get this error:": {
    "_translate": "当我们尝试检查这段代码时，我们得到了这个错误：",
    "_note": ""
  },
  "Let’s try passing a receiver of the channel into each worker as the thread pool creates the channel. We know we want to use the receiver in the thread that the workers spawn, so we’ll reference the receiver parameter in the closure. The code in Listing 21-17 won’t quite compile yet.": {
    "_translate": "让我们尝试在每个工作线程中传递通道的接收者，因为线程池创建了通道。我们知道我们希望在工作线程启动的线程中使用接收者，所以我们将引用<code>receiver</code>参数在闭包中。清单21-17中的代码还不能完全编译。",
    "_note": ""
  },
  "Additionally, taking a job off the channel queue involves mutating the receiver, so the threads need a safe way to share and modify receiver; otherwise, we might get race conditions (as covered in Chapter 16).": {
    "_translate": "此外，从通道队列中获取任务涉及修改<code>receiver</code>，因此线程需要一种安全的方式来共享和修改<code>receiver</code>；否则，我们可能会遇到竞争条件（如第16章所述）。",
    "_note": ""
  },
  "The code is trying to pass receiver to multiple Worker instances. This won’t work, as you’ll recall from Chapter 16: the channel implementation that Rust provides is multiple producer, single consumer. This means we can’t just clone the consuming end of the channel to fix this code. We also don’t want to send a message multiple times to multiple consumers; we want one list of messages with multiple workers such that each message gets processed once.": {
    "_translate": "代码试图将<code>receiver</code>传递给多个<code>Worker</code>实例。这\n不会奏效，正如你在第16章中所回忆的：Rust提供的通道实现是多个<em>生产者</em>，单个<em>消费者</em>。这意味着我们不能\n仅仅克隆通道的消费端来修复这段代码。我们也不希望将消息多次发送给多个消费者；我们希望有一个消息列表和多个工作线程，使得每个消息只被处理一次。",
    "_note": ""
  },
  "Recall the thread-safe smart pointers discussed in Chapter 16: to share ownership across multiple threads and allow the threads to mutate the value, we need to use Arc<Mutex<T>>. The Arc type will let multiple workers own the receiver, and Mutex will ensure that only one worker gets a job from the receiver at a time. Listing 21-18 shows the changes we need to make.": {
    "_translate": "回顾第 16 章讨论的线程安全智能指针：要跨多个线程共享所有权并允许线程修改值，我们需要使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。<code>Arc</code> 类型将让多个工作线程拥有接收者，而 <code>Mutex</code> 将确保一次只有一个工作线程从接收者那里获取任务。列表 21-18 显示了我们需要进行的更改。",
    "_note": ""
  },
  "With these changes, the code compiles! We’re getting there!": {
    "_translate": "有了这些更改，代码编译成功了！我们快到了！",
    "_note": ""
  },
  "In ThreadPool::new, we put the receiver in an Arc and a Mutex. For each new worker, we clone the Arc to bump the reference count so the workers can share ownership of the receiver.": {
    "_translate": "在 <code>ThreadPool::new</code> 中，我们将接收者放入一个 <code>Arc</code> 和一个 <code>Mutex</code> 中。对于每个新的工作线程，我们克隆 <code>Arc</code> 以增加引用计数，这样工作线程就可以共享接收者的所有权。",
    "_note": ""
  },
  "Let’s finally implement the execute method on ThreadPool. We’ll also change Job from a struct to a type alias for a trait object that holds the type of closure that execute receives. As discussed in the “Creating Type Synonyms with Type Aliases” section of Chapter 20, type aliases allow us to make long types shorter for ease of use. Look at Listing 21-19.": {
    "_translate": "让我们最终在 <code>ThreadPool</code> 上实现 <code>execute</code> 方法。我们还将 <code>Job</code> 从一个结构体改为一个类型别名，该别名表示 <code>execute</code> 接收的闭包类型。正如在第 20 章的 <a href=\"ch20-04-advanced-types.html#creating-type-synonyms-with-type-aliases\">“使用类型别名创建类型同义词”</a><!-- ignore -->\n部分讨论的那样，类型别名允许我们将长类型缩短以方便使用。请参见示例 21-19。",
    "_note": ""
  },
  "After creating a new Job instance using the closure we get in execute, we send that job down the sending end of the channel. We’re calling unwrap on send for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can’t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use unwrap is that we know the failure case won’t happen, but the compiler doesn’t know that.": {
    "_translate": "在使用 <code>execute</code> 中获得的闭包创建一个新的 <code>Job</code> 实例后，我们将该任务通过通道的发送端发送出去。我们在 <code>send</code> 上调用 <code>unwrap</code> 以处理发送失败的情况。例如，如果我们停止所有线程的执行，接收端停止接收新消息时，这种情况可能会发生。目前，我们无法停止线程的执行：只要线程池存在，我们的线程就会继续执行。我们使用 <code>unwrap</code> 的原因是我们知道失败的情况不会发生，但编译器不知道这一点。",
    "_note": ""
  },
  "But we’re not quite done yet! In the worker, our closure being passed to thread::spawn still only references the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let’s make the change shown in Listing 21-20 to Worker::new.": {
    "_translate": "但我们的工作还没有完全完成！在工作线程中，传递给 <code>thread::spawn</code> 的闭包仍然只是 <em>引用</em> 通道的接收端。相反，我们需要闭包无限循环，向通道的接收端请求任务，并在接收到任务时运行任务。让我们对 <code>Worker::new</code> 进行如清单 21-20 所示的更改。",
    "_note": ""
  },
  "Here, we first call lock on the receiver to acquire the mutex, and then we call unwrap to panic on any errors. Acquiring a lock might fail if the mutex is in a poisoned state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling unwrap to have this thread panic is the correct action to take. Feel free to change this unwrap to an expect with an error message that is meaningful to you.": {
    "_translate": "这里，我们首先调用 <code>receiver</code> 上的 <code>lock</code> 来获取互斥锁，然后我们调用 <code>unwrap</code> 来在任何错误时引发 panic。获取锁可能会失败，如果互斥锁处于 <em>中毒</em> 状态，这可能是因为其他线程在持有锁时引发了 panic 而不是释放锁。在这种情况下，调用 <code>unwrap</code> 使当前线程 panic 是正确的处理方式。你可以自由地将这个 <code>unwrap</code> 更改为带有对你有意义的错误消息的 <code>expect</code>。",
    "_note": ""
  },
  "If we get the lock on the mutex, we call recv to receive a Job from the channel. A final unwrap moves past any errors here as well, which might occur if the thread holding the sender has shut down, similar to how the send method returns Err if the receiver shuts down.": {
    "_translate": "如果我们获得了互斥锁，我们调用<code>recv</code>从通道接收一个<code>Job</code>。最后的<code>unwrap</code>也会跳过这里可能出现的任何错误，这可能发生在持有发送方的线程已关闭的情况下，类似于<code>send</code>方法在接收方关闭时返回<code>Err</code>。",
    "_note": ""
  },
  "The call to recv blocks, so if there is no job yet, the current thread will wait until a job becomes available. The Mutex<T> ensures that only one Worker thread at a time is trying to request a job.": {
    "_translate": "对 <code>recv</code> 的调用是阻塞的，因此如果没有任务，当前线程将等待任务变得可用。<code>Mutex&lt;T&gt;</code> 确保一次只有一个 <code>Worker</code> 线程尝试请求任务。",
    "_note": ""
  },
  "Our thread pool is now in a working state! Give it a cargo run and make some requests:": {
    "_translate": "我们的线程池现在处于工作状态！给它一个<code>cargo run</code>并发出一些请求：",
    "_note": ""
  },
  "Success! We now have a thread pool that executes connections asynchronously. There are never more than four threads created, so our system won’t get overloaded if the server receives a lot of requests. If we make a request to /sleep, the server will be able to serve other requests by having another thread run them.": {
    "_translate": "成功！我们现在有一个线程池，可以异步执行连接。\n线程池中永远不会创建超过四个线程，因此即使服务器收到大量请求，我们的系统也不会过载。如果我们向\n<em>/sleep</em> 发出请求，服务器将能够通过其他线程运行请求来为其他请求提供服务。",
    "_note": ""
  },
  "Note: If you open /sleep in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.": {
    "_translate": "注意：如果您同时在多个浏览器窗口中打开<em>/sleep</em>，它们可能会每隔5秒依次加载。一些网络浏览器出于缓存原因会顺序执行同一请求的多个实例。此限制并非由我们的网络服务器引起。",
    "_note": ""
  },
  "After learning about the while let loop in Chapters 17 and 18, you might be wondering why we didn’t write the worker thread code as shown in Listing 21-21.": {
    "_translate": "在学习了第17章和第18章的<code>while let</code>循环之后，你可能会疑惑为什么我们没有像清单21-21那样编写工作线程代码。",
    "_note": ""
  },
  "This is a good time to pause and consider how the code in Listings 21-18, 21-19, and 21-20 would be different if we were using futures instead of a closure for the work to be done. What types would change? How would the method signatures be different, if at all? What parts of the code would stay the same?": {
    "_translate": "这是暂停并考虑如果使用 future 而不是闭包来完成工作，清单 21-18、21-19 和 21-20 中的代码会有什么不同的好时机。哪些类型会改变？方法签名会有哪些不同，如果有的话？代码的哪些部分会保持不变？",
    "_note": ""
  },
  "This code compiles and runs but doesn’t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the Mutex struct has no public unlock method because the ownership of the lock is based on the lifetime of the MutexGuard<T> within the LockResult<MutexGuard<T>> that the lock method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a Mutex cannot be accessed unless we hold the lock. However, this implementation can also result in the lock being held longer than intended if we aren’t mindful of the lifetime of the MutexGuard<T>.": {
    "_translate": "这段代码可以编译和运行，但不会产生预期的线程行为：一个慢请求仍然会导致其他请求等待处理。原因比较微妙：<code>Mutex</code> 结构体没有公共的 <code>unlock</code> 方法，因为锁的所有权基于 <code>MutexGuard&lt;T&gt;</code> 在 <code>lock</code> 方法返回的 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 中的生命周期。在编译时，借用检查器可以强制执行规则，即除非我们持有锁，否则不能访问由 <code>Mutex</code> 保护的资源。然而，如果我们在意 <code>MutexGuard&lt;T&gt;</code> 的生命周期，这种实现也可能导致锁被持有时间超过预期。",
    "_note": ""
  },
  "The code in Listing 21-20 that uses let job = receiver.lock().unwrap().recv().unwrap(); works because with let, any temporary values used in the expression on the right hand side of the equals sign are immediately dropped when the let statement ends. However, while let (and if let and match) does not drop temporary values until the end of the associated block. In Listing 21-21, the lock remains held for the duration of the call to job(), meaning other workers cannot receive jobs.": {
    "_translate": "列表 21-20 中的代码使用 <code>let job = receiver.lock().unwrap().recv().unwrap();</code> 可以工作，因为使用 <code>let</code> 时，等号右侧表达式中使用的任何临时值在 <code>let</code> 语句结束时会立即被丢弃。然而，<code>while let</code>（以及 <code>if let</code> 和 <code>match</code>）不会在关联块结束之前丢弃临时值。在列表 21-21 中，锁在整个调用 <code>job()</code> 的期间一直被持有，这意味着其他工作线程无法接收任务。",
    "_note": ""
  }
}